DUMP COMPLETO DO PROJETO CAMPUSCALM
Gerado em: 2026-02-13T08:51:31-03:00
Diretorio base: /home/marcosdo/projetos/campuscalm

========================================
ESTRUTURA DE PASTAS E ARQUIVOS
========================================
.
.env.example
.gitignore
README.md
apps
apps/access_requests
apps/access_requests/__init__.py
apps/access_requests/__pycache__
apps/access_requests/__pycache__/__init__.cpython-312.pyc
apps/access_requests/__pycache__/admin.cpython-312.pyc
apps/access_requests/__pycache__/apps.cpython-312.pyc
apps/access_requests/__pycache__/models.cpython-312.pyc
apps/access_requests/__pycache__/serializers.cpython-312.pyc
apps/access_requests/__pycache__/urls.cpython-312.pyc
apps/access_requests/__pycache__/views.cpython-312.pyc
apps/access_requests/admin.py
apps/access_requests/apps.py
apps/access_requests/migrations
apps/access_requests/migrations/0001_initial.py
apps/access_requests/migrations/0002_initial.py
apps/access_requests/migrations/__init__.py
apps/access_requests/migrations/__pycache__
apps/access_requests/migrations/__pycache__/0001_initial.cpython-312.pyc
apps/access_requests/migrations/__pycache__/0002_initial.cpython-312.pyc
apps/access_requests/migrations/__pycache__/__init__.cpython-312.pyc
apps/access_requests/models.py
apps/access_requests/serializers.py
apps/access_requests/tests.py
apps/access_requests/urls.py
apps/access_requests/views.py
apps/accounts
apps/accounts/__init__.py
apps/accounts/__pycache__
apps/accounts/__pycache__/__init__.cpython-312.pyc
apps/accounts/__pycache__/admin.cpython-312.pyc
apps/accounts/__pycache__/apps.cpython-312.pyc
apps/accounts/__pycache__/models.cpython-312.pyc
apps/accounts/__pycache__/serializers.cpython-312.pyc
apps/accounts/__pycache__/signals.cpython-312.pyc
apps/accounts/__pycache__/urls.cpython-312.pyc
apps/accounts/__pycache__/views.cpython-312.pyc
apps/accounts/admin.py
apps/accounts/apps.py
apps/accounts/migrations
apps/accounts/migrations/0001_initial.py
apps/accounts/migrations/0002_userprofile.py
apps/accounts/migrations/__init__.py
apps/accounts/migrations/__pycache__
apps/accounts/migrations/__pycache__/0001_initial.cpython-312.pyc
apps/accounts/migrations/__pycache__/0002_userprofile.cpython-312.pyc
apps/accounts/migrations/__pycache__/__init__.cpython-312.pyc
apps/accounts/models.py
apps/accounts/serializers.py
apps/accounts/signals.py
apps/accounts/tests.py
apps/accounts/urls.py
apps/accounts/views.py
apps/agenda
apps/agenda/__init__.py
apps/agenda/__pycache__
apps/agenda/__pycache__/__init__.cpython-312.pyc
apps/agenda/__pycache__/admin.cpython-312.pyc
apps/agenda/__pycache__/apps.cpython-312.pyc
apps/agenda/__pycache__/models.cpython-312.pyc
apps/agenda/__pycache__/serializers.cpython-312.pyc
apps/agenda/__pycache__/urls.cpython-312.pyc
apps/agenda/__pycache__/views.cpython-312.pyc
apps/agenda/admin.py
apps/agenda/apps.py
apps/agenda/migrations
apps/agenda/migrations/0001_initial.py
apps/agenda/migrations/0002_alter_calendarevent_event_type_and_more.py
apps/agenda/migrations/__init__.py
apps/agenda/migrations/__pycache__
apps/agenda/migrations/__pycache__/0001_initial.cpython-312.pyc
apps/agenda/migrations/__pycache__/0002_alter_calendarevent_event_type_and_more.cpython-312.pyc
apps/agenda/migrations/__pycache__/__init__.cpython-312.pyc
apps/agenda/models.py
apps/agenda/serializers.py
apps/agenda/tests.py
apps/agenda/urls.py
apps/agenda/views.py
apps/analytics
apps/analytics/__init__.py
apps/analytics/__pycache__
apps/analytics/__pycache__/__init__.cpython-312.pyc
apps/analytics/__pycache__/admin.cpython-312.pyc
apps/analytics/__pycache__/apps.cpython-312.pyc
apps/analytics/__pycache__/models.cpython-312.pyc
apps/analytics/__pycache__/urls.cpython-312.pyc
apps/analytics/__pycache__/views.cpython-312.pyc
apps/analytics/admin.py
apps/analytics/apps.py
apps/analytics/management
apps/analytics/management/__init__.py
apps/analytics/management/__pycache__
apps/analytics/management/__pycache__/__init__.cpython-312.pyc
apps/analytics/management/commands
apps/analytics/management/commands/__init__.py
apps/analytics/management/commands/__pycache__
apps/analytics/management/commands/__pycache__/__init__.cpython-312.pyc
apps/analytics/management/commands/__pycache__/seed_demo_data.cpython-312.pyc
apps/analytics/management/commands/seed_demo_data.py
apps/analytics/migrations
apps/analytics/migrations/__init__.py
apps/analytics/migrations/__pycache__
apps/analytics/migrations/__pycache__/__init__.cpython-312.pyc
apps/analytics/models.py
apps/analytics/tests.py
apps/analytics/urls.py
apps/analytics/views.py
apps/billing
apps/billing/__init__.py
apps/billing/__pycache__
apps/billing/__pycache__/__init__.cpython-312.pyc
apps/billing/__pycache__/admin.cpython-312.pyc
apps/billing/__pycache__/apps.cpython-312.pyc
apps/billing/__pycache__/models.cpython-312.pyc
apps/billing/__pycache__/serializers.cpython-312.pyc
apps/billing/__pycache__/signals.cpython-312.pyc
apps/billing/__pycache__/urls.cpython-312.pyc
apps/billing/__pycache__/views.cpython-312.pyc
apps/billing/admin.py
apps/billing/apps.py
apps/billing/migrations
apps/billing/migrations/0001_initial.py
apps/billing/migrations/__init__.py
apps/billing/migrations/__pycache__
apps/billing/migrations/__pycache__/0001_initial.cpython-312.pyc
apps/billing/migrations/__pycache__/__init__.cpython-312.pyc
apps/billing/models.py
apps/billing/serializers.py
apps/billing/signals.py
apps/billing/tests.py
apps/billing/urls.py
apps/billing/views.py
apps/brain
apps/brain/__init__.py
apps/brain/__pycache__
apps/brain/__pycache__/__init__.cpython-312.pyc
apps/brain/__pycache__/admin.cpython-312.pyc
apps/brain/__pycache__/apps.cpython-312.pyc
apps/brain/__pycache__/constants.cpython-312.pyc
apps/brain/__pycache__/models.cpython-312.pyc
apps/brain/__pycache__/tests.cpython-312.pyc
apps/brain/__pycache__/urls.cpython-312.pyc
apps/brain/__pycache__/views.cpython-312.pyc
apps/brain/admin.py
apps/brain/apps.py
apps/brain/constants.py
apps/brain/migrations
apps/brain/migrations/0001_initial.py
apps/brain/migrations/0002_seed_initial_data.py
apps/brain/migrations/0003_seed_social_category.py
apps/brain/migrations/0004_expand_respostas_categorias.py
apps/brain/migrations/0005_seed_evolucao_category.py
apps/brain/migrations/0006_expand_evolucao_girias.py
apps/brain/migrations/0007_expand_evolucao_giria_maravilha.py
apps/brain/migrations/__init__.py
apps/brain/migrations/__pycache__
apps/brain/migrations/__pycache__/0001_initial.cpython-312.pyc
apps/brain/migrations/__pycache__/0002_seed_initial_data.cpython-312.pyc
apps/brain/migrations/__pycache__/0003_seed_social_category.cpython-312.pyc
apps/brain/migrations/__pycache__/0004_expand_respostas_categorias.cpython-312.pyc
apps/brain/migrations/__pycache__/0005_seed_evolucao_category.cpython-312.pyc
apps/brain/migrations/__pycache__/0006_expand_evolucao_girias.cpython-312.pyc
apps/brain/migrations/__pycache__/0007_expand_evolucao_giria_maravilha.cpython-312.pyc
apps/brain/migrations/__pycache__/__init__.cpython-312.pyc
apps/brain/models.py
apps/brain/tests.py
apps/brain/urls.py
apps/brain/views.py
apps/coach_ai
apps/coach_ai/__init__.py
apps/coach_ai/__pycache__
apps/coach_ai/__pycache__/__init__.cpython-312.pyc
apps/coach_ai/__pycache__/admin.cpython-312.pyc
apps/coach_ai/__pycache__/apps.cpython-312.pyc
apps/coach_ai/__pycache__/models.cpython-312.pyc
apps/coach_ai/admin.py
apps/coach_ai/apps.py
apps/coach_ai/migrations
apps/coach_ai/migrations/0001_initial.py
apps/coach_ai/migrations/__init__.py
apps/coach_ai/migrations/__pycache__
apps/coach_ai/migrations/__pycache__/0001_initial.cpython-312.pyc
apps/coach_ai/migrations/__pycache__/__init__.cpython-312.pyc
apps/coach_ai/models.py
apps/coach_ai/tests.py
apps/coach_ai/views.py
apps/content
apps/content/__init__.py
apps/content/__pycache__
apps/content/__pycache__/__init__.cpython-312.pyc
apps/content/__pycache__/admin.cpython-312.pyc
apps/content/__pycache__/apps.cpython-312.pyc
apps/content/__pycache__/models.cpython-312.pyc
apps/content/__pycache__/serializers.cpython-312.pyc
apps/content/__pycache__/urls.cpython-312.pyc
apps/content/__pycache__/views.cpython-312.pyc
apps/content/admin.py
apps/content/apps.py
apps/content/migrations
apps/content/migrations/0001_initial.py
apps/content/migrations/__init__.py
apps/content/migrations/__pycache__
apps/content/migrations/__pycache__/0001_initial.cpython-312.pyc
apps/content/migrations/__pycache__/__init__.cpython-312.pyc
apps/content/models.py
apps/content/serializers.py
apps/content/tests.py
apps/content/urls.py
apps/content/views.py
apps/mood
apps/mood/__init__.py
apps/mood/__pycache__
apps/mood/__pycache__/__init__.cpython-312.pyc
apps/mood/__pycache__/admin.cpython-312.pyc
apps/mood/__pycache__/apps.cpython-312.pyc
apps/mood/__pycache__/models.cpython-312.pyc
apps/mood/__pycache__/serializers.cpython-312.pyc
apps/mood/__pycache__/urls.cpython-312.pyc
apps/mood/__pycache__/views.cpython-312.pyc
apps/mood/admin.py
apps/mood/apps.py
apps/mood/migrations
apps/mood/migrations/0001_initial.py
apps/mood/migrations/__init__.py
apps/mood/migrations/__pycache__
apps/mood/migrations/__pycache__/0001_initial.cpython-312.pyc
apps/mood/migrations/__pycache__/__init__.cpython-312.pyc
apps/mood/models.py
apps/mood/serializers.py
apps/mood/tests.py
apps/mood/urls.py
apps/mood/views.py
apps/notifications
apps/notifications/__init__.py
apps/notifications/__pycache__
apps/notifications/__pycache__/__init__.cpython-312.pyc
apps/notifications/__pycache__/admin.cpython-312.pyc
apps/notifications/__pycache__/apps.cpython-312.pyc
apps/notifications/__pycache__/models.cpython-312.pyc
apps/notifications/__pycache__/serializers.cpython-312.pyc
apps/notifications/__pycache__/urls.cpython-312.pyc
apps/notifications/__pycache__/views.cpython-312.pyc
apps/notifications/admin.py
apps/notifications/apps.py
apps/notifications/management
apps/notifications/management/__init__.py
apps/notifications/management/__pycache__
apps/notifications/management/__pycache__/__init__.cpython-312.pyc
apps/notifications/management/commands
apps/notifications/management/commands/__init__.py
apps/notifications/management/commands/__pycache__
apps/notifications/management/commands/__pycache__/__init__.cpython-312.pyc
apps/notifications/management/commands/__pycache__/process_notification_queue.cpython-312.pyc
apps/notifications/management/commands/process_notification_queue.py
apps/notifications/migrations
apps/notifications/migrations/0001_initial.py
apps/notifications/migrations/0002_notificationqueue_action_taken_and_more.py
apps/notifications/migrations/__init__.py
apps/notifications/migrations/__pycache__
apps/notifications/migrations/__pycache__/0001_initial.cpython-312.pyc
apps/notifications/migrations/__pycache__/0002_notificationqueue_action_taken_and_more.cpython-312.pyc
apps/notifications/migrations/__pycache__/__init__.cpython-312.pyc
apps/notifications/models.py
apps/notifications/serializers.py
apps/notifications/services
apps/notifications/services/__pycache__
apps/notifications/services/__pycache__/reminder_queue.cpython-312.pyc
apps/notifications/services/__pycache__/whatsapp_cloud.cpython-312.pyc
apps/notifications/services/__pycache__/whatsapp_service.cpython-312.pyc
apps/notifications/services/reminder_queue.py
apps/notifications/services/whatsapp_cloud.py
apps/notifications/services/whatsapp_service.py
apps/notifications/tests.py
apps/notifications/urls.py
apps/notifications/views.py
apps/onboarding
apps/onboarding/__init__.py
apps/onboarding/__pycache__
apps/onboarding/__pycache__/__init__.cpython-312.pyc
apps/onboarding/__pycache__/admin.cpython-312.pyc
apps/onboarding/__pycache__/apps.cpython-312.pyc
apps/onboarding/__pycache__/models.cpython-312.pyc
apps/onboarding/__pycache__/services.cpython-312.pyc
apps/onboarding/__pycache__/signals.cpython-312.pyc
apps/onboarding/__pycache__/urls.cpython-312.pyc
apps/onboarding/__pycache__/views.cpython-312.pyc
apps/onboarding/admin.py
apps/onboarding/apps.py
apps/onboarding/migrations
apps/onboarding/migrations/0001_initial.py
apps/onboarding/migrations/__init__.py
apps/onboarding/migrations/__pycache__
apps/onboarding/migrations/__pycache__/0001_initial.cpython-312.pyc
apps/onboarding/migrations/__pycache__/__init__.cpython-312.pyc
apps/onboarding/models.py
apps/onboarding/services.py
apps/onboarding/signals.py
apps/onboarding/tests.py
apps/onboarding/urls.py
apps/onboarding/views.py
apps/planner
apps/planner/__init__.py
apps/planner/__pycache__
apps/planner/__pycache__/__init__.cpython-312.pyc
apps/planner/__pycache__/admin.cpython-312.pyc
apps/planner/__pycache__/apps.cpython-312.pyc
apps/planner/__pycache__/models.cpython-312.pyc
apps/planner/__pycache__/serializers.cpython-312.pyc
apps/planner/__pycache__/urls.cpython-312.pyc
apps/planner/__pycache__/views.cpython-312.pyc
apps/planner/admin.py
apps/planner/apps.py
apps/planner/migrations
apps/planner/migrations/0001_initial.py
apps/planner/migrations/__init__.py
apps/planner/migrations/__pycache__
apps/planner/migrations/__pycache__/0001_initial.cpython-312.pyc
apps/planner/migrations/__pycache__/__init__.cpython-312.pyc
apps/planner/models.py
apps/planner/serializers.py
apps/planner/tests.py
apps/planner/urls.py
apps/planner/views.py
apps/pomodoro
apps/pomodoro/__init__.py
apps/pomodoro/__pycache__
apps/pomodoro/__pycache__/__init__.cpython-312.pyc
apps/pomodoro/__pycache__/admin.cpython-312.pyc
apps/pomodoro/__pycache__/apps.cpython-312.pyc
apps/pomodoro/__pycache__/models.cpython-312.pyc
apps/pomodoro/__pycache__/serializers.cpython-312.pyc
apps/pomodoro/__pycache__/urls.cpython-312.pyc
apps/pomodoro/__pycache__/views.cpython-312.pyc
apps/pomodoro/admin.py
apps/pomodoro/apps.py
apps/pomodoro/migrations
apps/pomodoro/migrations/0001_initial.py
apps/pomodoro/migrations/__init__.py
apps/pomodoro/migrations/__pycache__
apps/pomodoro/migrations/__pycache__/0001_initial.cpython-312.pyc
apps/pomodoro/migrations/__pycache__/__init__.cpython-312.pyc
apps/pomodoro/models.py
apps/pomodoro/serializers.py
apps/pomodoro/tests.py
apps/pomodoro/urls.py
apps/pomodoro/views.py
apps/semester
apps/semester/__init__.py
apps/semester/__pycache__
apps/semester/__pycache__/__init__.cpython-312.pyc
apps/semester/__pycache__/admin.cpython-312.pyc
apps/semester/__pycache__/apps.cpython-312.pyc
apps/semester/__pycache__/models.cpython-312.pyc
apps/semester/__pycache__/serializers.cpython-312.pyc
apps/semester/__pycache__/urls.cpython-312.pyc
apps/semester/__pycache__/views.cpython-312.pyc
apps/semester/admin.py
apps/semester/apps.py
apps/semester/migrations
apps/semester/migrations/0001_initial.py
apps/semester/migrations/__init__.py
apps/semester/migrations/__pycache__
apps/semester/migrations/__pycache__/0001_initial.cpython-312.pyc
apps/semester/migrations/__pycache__/__init__.cpython-312.pyc
apps/semester/models.py
apps/semester/serializers.py
apps/semester/tests.py
apps/semester/urls.py
apps/semester/views.py
apps/ui
apps/ui/__init__.py
apps/ui/__pycache__
apps/ui/__pycache__/__init__.cpython-312.pyc
apps/ui/__pycache__/apps.cpython-312.pyc
apps/ui/__pycache__/forms.cpython-312.pyc
apps/ui/__pycache__/forms_academic.cpython-312.pyc
apps/ui/__pycache__/forms_agenda.cpython-312.pyc
apps/ui/__pycache__/forms_reminders.cpython-312.pyc
apps/ui/__pycache__/forms_tasks.cpython-312.pyc
apps/ui/__pycache__/services_academic.cpython-312.pyc
apps/ui/__pycache__/urls.cpython-312.pyc
apps/ui/__pycache__/views.cpython-312.pyc
apps/ui/__pycache__/views_academic.cpython-312.pyc
apps/ui/__pycache__/views_agenda.cpython-312.pyc
apps/ui/__pycache__/views_messages.cpython-312.pyc
apps/ui/__pycache__/views_reminders.cpython-312.pyc
apps/ui/__pycache__/views_tasks.cpython-312.pyc
apps/ui/apps.py
apps/ui/forms.py
apps/ui/forms_academic.py
apps/ui/forms_agenda.py
apps/ui/forms_reminders.py
apps/ui/forms_tasks.py
apps/ui/services_academic.py
apps/ui/urls.py
apps/ui/views.py
apps/ui/views_academic.py
apps/ui/views_agenda.py
apps/ui/views_messages.py
apps/ui/views_reminders.py
apps/ui/views_tasks.py
config
config/__init__.py
config/__pycache__
config/__pycache__/__init__.cpython-312.pyc
config/__pycache__/settings.cpython-312.pyc
config/__pycache__/settings_migrations.cpython-312.pyc
config/__pycache__/urls.cpython-312.pyc
config/__pycache__/views.cpython-312.pyc
config/__pycache__/wsgi.cpython-312.pyc
config/asgi.py
config/settings.py
config/settings_migrations.py
config/urls.py
config/views.py
config/wsgi.py
docs
docs/TESTE_NOTIFICACOES.md
docs/dump_completo_projeto_20260213_085131.txt
docs/full_dump.txt
docs/full_dump_atual.txt
docs/home_changes_for_chatgpt.md
locale
locale/en
locale/en/LC_MESSAGES
locale/en/LC_MESSAGES/django.mo
locale/en/LC_MESSAGES/django.po
locale/pt_BR
locale/pt_BR/LC_MESSAGES
locale/pt_BR/LC_MESSAGES/django.mo
locale/pt_BR/LC_MESSAGES/django.po
locale/pt_PT
locale/pt_PT/LC_MESSAGES
locale/pt_PT/LC_MESSAGES/django.mo
locale/pt_PT/LC_MESSAGES/django.po
manage.py
requirements.txt
scripts
scripts/i18n_refresh.sh
scripts/run_curl_demo.sh
static
static/css
static/css/app.css
static/css/home.css
static/css/student.css
static/img
static/img/logo-campus-calm.png
static/img/logoalgorithminsights_empresa.png
static/ui
static/ui/css
static/ui/css/campuscalm_widget.css
static/ui/js
static/ui/js/campuscalm_widget.js
templates
templates/accounts
templates/accounts/email
templates/accounts/email/activate_account.html
templates/accounts/email/activate_account.txt
templates/base.html
templates/registration
templates/registration/password_reset_email.html
templates/registration/password_reset_subject.txt
templates/ui
templates/ui/agenda
templates/ui/agenda.html
templates/ui/agenda/agenda_confirm_delete.html
templates/ui/agenda/agenda_form.html
templates/ui/agenda/agenda_list.html
templates/ui/assessment
templates/ui/assessment/assessment_confirm_delete.html
templates/ui/assessment/assessment_form.html
templates/ui/auth_base.html
templates/ui/base_student.html
templates/ui/course
templates/ui/course/course_confirm_delete.html
templates/ui/course/course_detail.html
templates/ui/course/course_form.html
templates/ui/dashboard.html
templates/ui/first_access.html
templates/ui/home.html
templates/ui/login.html
templates/ui/messages
templates/ui/messages.html
templates/ui/messages/message_list.html
templates/ui/onboarding.html
templates/ui/partials
templates/ui/partials/campuscalm_widget.html
templates/ui/password_reset_complete.html
templates/ui/password_reset_confirm.html
templates/ui/password_reset_done.html
templates/ui/password_reset_form.html
templates/ui/reminders
templates/ui/reminders/reminder_confirm_delete.html
templates/ui/reminders/reminder_form.html
templates/ui/reminders/reminder_list.html
templates/ui/semester
templates/ui/semester/semester_confirm_delete.html
templates/ui/semester/semester_detail.html
templates/ui/semester/semester_form.html
templates/ui/semester/semester_list.html
templates/ui/semesters.html
templates/ui/tasks
templates/ui/tasks.html
templates/ui/tasks/task_confirm_delete.html
templates/ui/tasks/task_detail.html
templates/ui/tasks/task_form.html
templates/ui/tasks/task_list.html
utils
utils/__init__.py
utils/__pycache__
utils/__pycache__/__init__.cpython-312.pyc
utils/__pycache__/academic_progress.cpython-312.pyc
utils/__pycache__/constants.cpython-312.pyc
utils/__pycache__/features.cpython-312.pyc
utils/__pycache__/gating.cpython-312.pyc
utils/__pycache__/messages.cpython-312.pyc
utils/__pycache__/triage.cpython-312.pyc
utils/academic_progress.py
utils/constants.py
utils/features.py
utils/gating.py
utils/messages.py
utils/triage.py

========================================
CONTEUDO DOS ARQUIVOS DE TEXTO
========================================

----- BEGIN FILE: .gitignore -----
.venv/
__pycache__/
*.pyc
*.pyo
*.pyd
*.sqlite3
*.log
.DS_Store
.env
.env.*
*:Zone.Identifier

----- END FILE: .gitignore -----

----- BEGIN FILE: README.md -----
# Campus Calm (MVP)

MVP para universitarios acompanharem o semestre com bem-estar, organizacao e foco. O projeto usa Django + Django REST Framework, autenticacao JWT e banco SQLite em dev.

## Requisitos
- Python 3.12+
- Pip

## Setup rapido
```bash
python3 -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt

python manage.py migrate
python manage.py createsuperuser
python manage.py runserver
```

## Variaveis de ambiente
Copie `.env.example` e ajuste conforme necessario. A variavel `TRIAGE_USE_LLM` prepara a triagem para LLM futuro (mock no MVP).

## Endpoints principais
- Auth: `/api/auth/register/`, `/api/auth/login/`, `/api/auth/refresh/`, `/api/auth/me/`
- Billing: `/api/billing/plan/`, `/api/billing/set-plan/` (admin)
- Onboarding: `/api/onboarding/status/`
- Mood: `/api/mood/entries/`, `/api/mood/summary/weekly/`
- Pomodoro: `/api/pomodoro/start/`, `/api/pomodoro/stop/{id}/`, `/api/pomodoro/summary/weekly/`
- Planner: `/api/planner/tasks/`
- Agenda: `/api/agenda/events/`, `/api/agenda/week/`, `/api/agenda/generate-reminders/`
- Semester: `/api/semester/semesters/`, `/api/semester/courses/`, `/api/semester/assessments/`, `/api/semester/courses/{id}/progress/`, `/api/semester/finish/{semester_id}/`
- Content: `/api/content/guided/`, `/api/content/guided/{id}/`
- Notifications: `/api/notifications/test-email/`, `/api/notifications/pending/`
- Access Requests: `/api/access/requests/`, `/api/access/requests/{id}/approve/`, `/api/access/requests/{id}/reject/`, `/api/access/triage/{id}/log/`
- Analytics: `/api/analytics/dashboard/`, `/api/analytics/semester/{semester_id}/`

## Documentacao automatica
- Schema: `/api/schema/`
- Swagger UI: `/api/docs/`

## Exemplos com curl
### Registrar
```bash
curl -X POST http://localhost:8000/api/auth/register/ \
  -H "Content-Type: application/json" \
  -d '{"email":"aluno@exemplo.com","name":"Aluno","password":"senha123"}'
```

### Login
```bash
curl -X POST http://localhost:8000/api/auth/login/ \
  -H "Content-Type: application/json" \
  -d '{"email":"aluno@exemplo.com","password":"senha123"}'
```

### Criar check-in de humor
```bash
curl -X POST http://localhost:8000/api/mood/entries/ \
  -H "Authorization: Bearer <ACCESS_TOKEN>" \
  -H "Content-Type: application/json" \
  -d '{"mood":"OK","notes":"Dia produtivo"}'
```

### Criar tarefa
```bash
curl -X POST http://localhost:8000/api/planner/tasks/ \
  -H "Authorization: Bearer <ACCESS_TOKEN>" \
  -H "Content-Type: application/json" \
  -d '{"title":"Trabalho final","due_date":"2026-03-10","stress_level":3,"status":"TODO"}'
```

### Criar regra de lembrete e gerar notificacoes
```bash
curl -X POST http://localhost:8000/api/agenda/reminder-rules/ \
  -H "Authorization: Bearer <ACCESS_TOKEN>" \
  -H "Content-Type: application/json" \
  -d '{"target_type":"TASK","remind_before_minutes":60,"channels":["EMAIL"],"is_active":true}'

curl -X POST http://localhost:8000/api/agenda/generate-reminders/ \
  -H "Authorization: Bearer <ACCESS_TOKEN>" \
  -H "Content-Type: application/json" \
  -d '{}'
```

### Solicitar acesso (triagem automatica)
```bash
curl -X POST http://localhost:8000/api/access/requests/ \
  -H "Content-Type: application/json" \
  -d '{"requester_email":"coord@faculdade.com","requester_type":"INSTITUTION","estimated_users":120}'
```

## Health-check
```bash
curl http://localhost:8000/health/
```

## Script de demo (curl)
```bash
bash scripts/run_curl_demo.sh
```

## Seed de dados (mais completo)
```bash
python manage.py seed_demo_data --email nari.naluu@gmail.com
```

## Notificacoes
- Email: backend console em dev.
- WhatsApp/SMS: mock no MVP.

Processar fila manualmente:
```bash
python manage.py process_notification_queue
```

## Sistema de mensagens
O Campus Calm usa um **Message Framework** centralizado em `utils/messages.py`.
- Tipos: REMINDER, CARE, INCENTIVE, WARNING, ACHIEVEMENT, SYSTEM
- Canais: IN_APP (sempre), EMAIL (conforme plano), WHATSAPP/SMS (mock)
- Todas as mensagens usam tom calmo e nao clinico.

As mensagens ficam registradas em `notifications.NotificationQueue`.

## Progresso academico
Os calculos de progresso ficam em `utils/academic_progress.py`:
- **media ponderada** por peso
- **progress_percent** limitado a 100%
- **needed_to_pass** nunca negativo

Regras de status:
- progress_percent >= 100% -> PASSED
- semestre finalizado e progress_percent < 100% -> FAILED
- caso contrario -> IN_PROGRESS

Mensagens automaticas:
- Nova nota: INCENTIVE (progresso subiu) ou CARE (progresso caiu)
- Progresso < 70% com avaliacao proxima: WARNING suave
- Disciplina atinge 100%: ACHIEVEMENT
- Finalizar semestre: ACHIEVEMENT se todas aprovadas; CARE + INCENTIVE se alguma reprovada

## Observacoes de seguranca
- O sistema nao e um dispositivo medico.
- Em humor muito baixo recorrente, o sistema recomenda apoio profissional (ex: CVV 188).

## Tests
```bash
python manage.py test
```

----- END FILE: README.md -----

----- BEGIN FILE: apps/access_requests/admin.py -----
from django.contrib import admin

from access_requests.models import AccessRequest, AITriageLog


@admin.register(AccessRequest)
class AccessRequestAdmin(admin.ModelAdmin):
    list_display = ("requester_email", "requester_type", "status", "recommended_plan", "decided_plan")
    list_filter = ("status", "requester_type")
    search_fields = ("requester_email", "requester_name")


@admin.register(AITriageLog)
class AITriageLogAdmin(admin.ModelAdmin):
    list_display = ("access_request", "model_name", "created_at")

----- END FILE: apps/access_requests/admin.py -----

----- BEGIN FILE: apps/access_requests/apps.py -----
from django.apps import AppConfig


class AccessRequestsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'access_requests'

----- END FILE: apps/access_requests/apps.py -----

----- BEGIN FILE: apps/access_requests/migrations/0001_initial.py -----
# Generated by Django 4.2.11 on 2026-01-28 13:35

from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='AccessRequest',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('requester_email', models.EmailField(max_length=254)),
                ('requester_name', models.CharField(blank=True, max_length=255)),
                ('requester_type', models.CharField(choices=[('INDIVIDUAL', 'Individual'), ('INSTITUTION', 'Institution')], max_length=20)),
                ('institution_name', models.CharField(blank=True, max_length=255)),
                ('estimated_users', models.PositiveIntegerField(blank=True, null=True)),
                ('wants_features', models.JSONField(default=list)),
                ('message', models.TextField(blank=True)),
                ('status', models.CharField(choices=[('PENDING', 'Pending'), ('APPROVED', 'Approved'), ('REJECTED', 'Rejected')], default='PENDING', max_length=20)),
                ('recommended_plan', models.CharField(blank=True, choices=[('LITE', 'Lite'), ('PRO', 'Pro')], max_length=10)),
                ('decided_plan', models.CharField(blank=True, choices=[('LITE', 'Lite'), ('PRO', 'Pro')], max_length=10)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
        ),
        migrations.CreateModel(
            name='AITriageLog',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('model_name', models.CharField(max_length=100)),
                ('input_payload', models.JSONField()),
                ('output_payload', models.JSONField()),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('access_request', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='triage_logs', to='access_requests.accessrequest')),
            ],
        ),
    ]

----- END FILE: apps/access_requests/migrations/0001_initial.py -----

----- BEGIN FILE: apps/access_requests/migrations/0002_initial.py -----
# Generated by Django 4.2.11 on 2026-01-28 13:35

from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('access_requests', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.AddField(
            model_name='accessrequest',
            name='created_user',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL),
        ),
    ]

----- END FILE: apps/access_requests/migrations/0002_initial.py -----

----- BEGIN FILE: apps/access_requests/models.py -----
from django.conf import settings
from django.db import models

from utils.constants import ACCESS_STATUS_CHOICES, ACCESS_PENDING, PLAN_CHOICES, REQUESTER_TYPE_CHOICES


class AccessRequest(models.Model):
    requester_email = models.EmailField()
    requester_name = models.CharField(max_length=255, blank=True)
    requester_type = models.CharField(max_length=20, choices=REQUESTER_TYPE_CHOICES)
    institution_name = models.CharField(max_length=255, blank=True)
    estimated_users = models.PositiveIntegerField(null=True, blank=True)
    wants_features = models.JSONField(default=list)
    message = models.TextField(blank=True)
    status = models.CharField(max_length=20, choices=ACCESS_STATUS_CHOICES, default=ACCESS_PENDING)
    recommended_plan = models.CharField(max_length=10, choices=PLAN_CHOICES, blank=True)
    decided_plan = models.CharField(max_length=10, choices=PLAN_CHOICES, blank=True)
    created_user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.requester_email


class AITriageLog(models.Model):
    access_request = models.ForeignKey(AccessRequest, on_delete=models.CASCADE, related_name="triage_logs")
    model_name = models.CharField(max_length=100)
    input_payload = models.JSONField()
    output_payload = models.JSONField()
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.access_request.id} - {self.model_name}"

----- END FILE: apps/access_requests/models.py -----

----- BEGIN FILE: apps/access_requests/serializers.py -----
from rest_framework import serializers

from access_requests.models import AccessRequest, AITriageLog
from utils.constants import ACCESS_APPROVED, ACCESS_REJECTED


class AccessRequestCreateSerializer(serializers.ModelSerializer):
    class Meta:
        model = AccessRequest
        fields = (
            "id",
            "requester_email",
            "requester_name",
            "requester_type",
            "institution_name",
            "estimated_users",
            "wants_features",
            "message",
            "status",
            "recommended_plan",
            "created_at",
        )
        read_only_fields = ("id", "status", "recommended_plan", "created_at")


class AccessRequestSerializer(serializers.ModelSerializer):
    class Meta:
        model = AccessRequest
        fields = "__all__"


class AITriageLogSerializer(serializers.ModelSerializer):
    class Meta:
        model = AITriageLog
        fields = ("id", "model_name", "input_payload", "output_payload", "created_at")
        read_only_fields = fields


class AccessDecisionSerializer(serializers.Serializer):
    decided_plan = serializers.CharField(required=False)

    def validate_decided_plan(self, value):
        if value and value not in {"LITE", "PRO"}:
            raise serializers.ValidationError("Plano invalido")
        return value

----- END FILE: apps/access_requests/serializers.py -----

----- BEGIN FILE: apps/access_requests/tests.py -----
from rest_framework.test import APITestCase

from utils.constants import FEATURE_EMAIL_NOTIFICATIONS, PLAN_PRO


class AccessRequestTriageTests(APITestCase):
    def test_triage_recommends_pro(self):
        payload = {
            "requester_email": "inst@example.com",
            "requester_type": "INDIVIDUAL",
            "wants_features": [FEATURE_EMAIL_NOTIFICATIONS],
        }
        response = self.client.post("/api/access/requests/", payload, format="json")
        self.assertEqual(response.status_code, 201)
        self.assertEqual(response.data["recommended_plan"], PLAN_PRO)

----- END FILE: apps/access_requests/tests.py -----

----- BEGIN FILE: apps/access_requests/urls.py -----
from django.urls import path

from access_requests.views import (
    AccessApproveView,
    AccessRejectView,
    AccessRequestDetailView,
    AccessRequestListCreateView,
    AccessTriageLogView,
)

urlpatterns = [
    path("requests/", AccessRequestListCreateView.as_view(), name="access-request-list-create"),
    path("requests/<int:pk>/", AccessRequestDetailView.as_view(), name="access-request-detail"),
    path("requests/<int:pk>/approve/", AccessApproveView.as_view(), name="access-request-approve"),
    path("requests/<int:pk>/reject/", AccessRejectView.as_view(), name="access-request-reject"),
    path("triage/<int:pk>/log/", AccessTriageLogView.as_view(), name="access-triage-log"),
]

----- END FILE: apps/access_requests/urls.py -----

----- BEGIN FILE: apps/access_requests/views.py -----
from django.shortcuts import get_object_or_404
from rest_framework import permissions, status
from rest_framework.response import Response
from rest_framework.views import APIView

from access_requests.models import AccessRequest, AITriageLog
from access_requests.serializers import (
    AccessDecisionSerializer,
    AccessRequestCreateSerializer,
    AccessRequestSerializer,
    AITriageLogSerializer,
)
from utils.constants import ACCESS_APPROVED, ACCESS_REJECTED
from utils.triage import TRIAGE_MODEL_NAME, run_triage


class AccessRequestListCreateView(APIView):
    def get_permissions(self):
        if self.request.method == "POST":
            return [permissions.AllowAny()]
        return [permissions.IsAdminUser()]

    def get(self, request):
        requests = AccessRequest.objects.all().order_by("-created_at")
        return Response(AccessRequestSerializer(requests, many=True).data)

    def post(self, request):
        serializer = AccessRequestCreateSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        access_request = serializer.save()
        triage_result = run_triage(access_request)
        recommended_plan = triage_result["recommended_plan"]
        access_request.recommended_plan = recommended_plan
        access_request.save(update_fields=["recommended_plan"])
        input_payload = serializer.validated_data
        output_payload = triage_result["output_payload"]
        AITriageLog.objects.create(
            access_request=access_request,
            model_name=TRIAGE_MODEL_NAME,
            input_payload=input_payload,
            output_payload=output_payload,
        )
        return Response(AccessRequestCreateSerializer(access_request).data, status=status.HTTP_201_CREATED)


class AccessRequestDetailView(APIView):
    permission_classes = [permissions.IsAdminUser]

    def get(self, request, pk):
        access_request = get_object_or_404(AccessRequest, pk=pk)
        return Response(AccessRequestSerializer(access_request).data)


class AccessApproveView(APIView):
    permission_classes = [permissions.IsAdminUser]

    def post(self, request, pk):
        access_request = get_object_or_404(AccessRequest, pk=pk)
        serializer = AccessDecisionSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        access_request.status = ACCESS_APPROVED
        access_request.decided_plan = serializer.validated_data.get("decided_plan") or access_request.recommended_plan
        access_request.save(update_fields=["status", "decided_plan"])
        return Response(AccessRequestSerializer(access_request).data)


class AccessRejectView(APIView):
    permission_classes = [permissions.IsAdminUser]

    def post(self, request, pk):
        access_request = get_object_or_404(AccessRequest, pk=pk)
        access_request.status = ACCESS_REJECTED
        access_request.save(update_fields=["status"])
        return Response(AccessRequestSerializer(access_request).data)


class AccessTriageLogView(APIView):
    permission_classes = [permissions.IsAdminUser]

    def get(self, request, pk):
        access_request = get_object_or_404(AccessRequest, pk=pk)
        log = access_request.triage_logs.order_by("-created_at").first()
        if not log:
            return Response({"detail": "Sem log de triagem."}, status=status.HTTP_404_NOT_FOUND)
        return Response(AITriageLogSerializer(log).data)

----- END FILE: apps/access_requests/views.py -----

----- BEGIN FILE: apps/accounts/admin.py -----
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as DjangoUserAdmin

from accounts.models import User, UserProfile


@admin.register(User)
class UserAdmin(DjangoUserAdmin):
    model = User
    ordering = ("email",)
    list_display = ("email", "name", "is_staff", "is_active", "created_at")
    search_fields = ("email", "name")
    fieldsets = (
        (None, {"fields": ("email", "password")}),
        ("Personal info", {"fields": ("name", "phone_number")}),
        ("Permissions", {"fields": ("is_active", "is_staff", "is_superuser", "groups", "user_permissions")}),
        ("Important dates", {"fields": ("last_login",)}),
    )
    add_fieldsets = (
        (
            None,
            {
                "classes": ("wide",),
                "fields": ("email", "name", "password1", "password2", "is_staff", "is_superuser"),
            },
        ),
    )


@admin.register(UserProfile)
class UserProfileAdmin(admin.ModelAdmin):
    list_display = ("user", "plan", "allow_email", "allow_whatsapp", "allow_sms", "consent_at")
    list_filter = ("plan", "allow_email", "allow_whatsapp", "allow_sms")

----- END FILE: apps/accounts/admin.py -----

----- BEGIN FILE: apps/accounts/apps.py -----
from django.apps import AppConfig


class AccountsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'accounts'

    def ready(self):
        from accounts import signals  # noqa: F401

----- END FILE: apps/accounts/apps.py -----

----- BEGIN FILE: apps/accounts/migrations/0001_initial.py -----
# Generated by Django 4.2.11 on 2026-01-28 13:35

from django.db import migrations, models
import django.utils.timezone


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('auth', '0012_alter_user_first_name_max_length'),
    ]

    operations = [
        migrations.CreateModel(
            name='User',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('password', models.CharField(max_length=128, verbose_name='password')),
                ('last_login', models.DateTimeField(blank=True, null=True, verbose_name='last login')),
                ('is_superuser', models.BooleanField(default=False, help_text='Designates that this user has all permissions without explicitly assigning them.', verbose_name='superuser status')),
                ('email', models.EmailField(max_length=254, unique=True)),
                ('name', models.CharField(max_length=255)),
                ('phone_number', models.CharField(blank=True, max_length=30)),
                ('created_at', models.DateTimeField(default=django.utils.timezone.now)),
                ('is_active', models.BooleanField(default=True)),
                ('is_staff', models.BooleanField(default=False)),
                ('groups', models.ManyToManyField(blank=True, help_text='The groups this user belongs to. A user will get all permissions granted to each of their groups.', related_name='user_set', related_query_name='user', to='auth.group', verbose_name='groups')),
                ('user_permissions', models.ManyToManyField(blank=True, help_text='Specific permissions for this user.', related_name='user_set', related_query_name='user', to='auth.permission', verbose_name='user permissions')),
            ],
            options={
                'abstract': False,
            },
        ),
    ]

----- END FILE: apps/accounts/migrations/0001_initial.py -----

----- BEGIN FILE: apps/accounts/migrations/0002_userprofile.py -----
# Generated by Django 6.0.1 on 2026-02-02 14:09

import django.db.models.deletion
import django.utils.timezone
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('accounts', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='UserProfile',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('phone', models.CharField(blank=True, max_length=30)),
                ('plan', models.CharField(choices=[('FREE', 'Free'), ('PAGO', 'Pago')], default='FREE', max_length=10)),
                ('allow_whatsapp', models.BooleanField(default=True)),
                ('allow_sms', models.BooleanField(default=False)),
                ('allow_email', models.BooleanField(default=True)),
                ('consent_at', models.DateTimeField(default=django.utils.timezone.now)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('user', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='profile', to=settings.AUTH_USER_MODEL)),
            ],
        ),
    ]

----- END FILE: apps/accounts/migrations/0002_userprofile.py -----

----- BEGIN FILE: apps/accounts/models.py -----
from django.contrib.auth.models import AbstractBaseUser, BaseUserManager, PermissionsMixin
from django.db import models
from django.utils import timezone


class UserManager(BaseUserManager):
    def create_user(self, email, password=None, **extra_fields):
        if not email:
            raise ValueError("Email is required")
        email = self.normalize_email(email)
        user = self.model(email=email, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, email, password=None, **extra_fields):
        extra_fields.setdefault("is_staff", True)
        extra_fields.setdefault("is_superuser", True)
        extra_fields.setdefault("is_active", True)
        if not extra_fields.get("is_staff"):
            raise ValueError("Superuser must have is_staff=True")
        if not extra_fields.get("is_superuser"):
            raise ValueError("Superuser must have is_superuser=True")
        return self.create_user(email, password, **extra_fields)


class User(AbstractBaseUser, PermissionsMixin):
    email = models.EmailField(unique=True)
    name = models.CharField(max_length=255)
    phone_number = models.CharField(max_length=30, blank=True)
    created_at = models.DateTimeField(default=timezone.now)

    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)

    objects = UserManager()

    EMAIL_FIELD = "email"
    USERNAME_FIELD = "email"
    REQUIRED_FIELDS = ["name"]

    def __str__(self):
        return self.email


# Bloco: Perfil e consentimentos do usuario
class UserProfile(models.Model):
    PLAN_FREE = "FREE"
    PLAN_PAID = "PAGO"
    PLAN_CHOICES = [
        (PLAN_FREE, "Free"),
        (PLAN_PAID, "Pago"),
    ]

    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name="profile")
    phone = models.CharField(max_length=30, blank=True)
    plan = models.CharField(max_length=10, choices=PLAN_CHOICES, default=PLAN_FREE)
    allow_whatsapp = models.BooleanField(default=True)
    allow_sms = models.BooleanField(default=False)
    allow_email = models.BooleanField(default=True)
    consent_at = models.DateTimeField(default=timezone.now)
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.user.email} profile"

----- END FILE: apps/accounts/models.py -----

----- BEGIN FILE: apps/accounts/serializers.py -----
from django.contrib.auth import get_user_model
from rest_framework import serializers

User = get_user_model()


class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ("id", "email", "name", "phone_number", "created_at")
        read_only_fields = ("id", "created_at")


class RegisterSerializer(serializers.ModelSerializer):
    password = serializers.CharField(write_only=True, min_length=6)

    class Meta:
        model = User
        fields = ("email", "name", "phone_number", "password")

    def create(self, validated_data):
        password = validated_data.pop("password")
        user = User.objects.create_user(password=password, **validated_data)
        return user

----- END FILE: apps/accounts/serializers.py -----

----- BEGIN FILE: apps/accounts/signals.py -----
from django.db.models.signals import post_save
from django.dispatch import receiver

from accounts.models import User, UserProfile


# Bloco: Criacao automatica de perfil
@receiver(post_save, sender=User)
def ensure_user_profile(sender, instance, created, **kwargs):
    if created:
        UserProfile.objects.get_or_create(
            user=instance,
            defaults={
                "phone": instance.phone_number or "",
                "plan": UserProfile.PLAN_FREE,
                "allow_whatsapp": True,
                "allow_sms": False,
                "allow_email": True,
            },
        )

----- END FILE: apps/accounts/signals.py -----

----- BEGIN FILE: apps/accounts/tests.py -----
from django.urls import reverse
from rest_framework.test import APITestCase


class AuthTests(APITestCase):
    def test_register_and_login(self):
        register_url = "/api/auth/register/"
        payload = {
            "email": "test@example.com",
            "name": "Teste",
            "password": "strongpass123",
        }
        response = self.client.post(register_url, payload, format="json")
        self.assertEqual(response.status_code, 201)
        self.assertIn("access", response.data)

        login_url = "/api/auth/login/"
        login_response = self.client.post(login_url, {"email": payload["email"], "password": payload["password"]})
        self.assertEqual(login_response.status_code, 200)
        self.assertIn("access", login_response.data)

----- END FILE: apps/accounts/tests.py -----

----- BEGIN FILE: apps/accounts/urls.py -----
from django.urls import path
from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView

from accounts.views import MeView, RegisterView

urlpatterns = [
    path("register/", RegisterView.as_view(), name="auth-register"),
    path("login/", TokenObtainPairView.as_view(), name="auth-login"),
    path("refresh/", TokenRefreshView.as_view(), name="auth-refresh"),
    path("me/", MeView.as_view(), name="auth-me"),
]

----- END FILE: apps/accounts/urls.py -----

----- BEGIN FILE: apps/accounts/views.py -----
from rest_framework import permissions, status
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework_simplejwt.tokens import RefreshToken

from accounts.serializers import RegisterSerializer, UserSerializer
from billing.models import Plan, UserSubscription
from utils.constants import PLAN_LITE


class RegisterView(APIView):
    permission_classes = [permissions.AllowAny]

    def post(self, request):
        serializer = RegisterSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user = serializer.save()
        plan = Plan.objects.filter(code=PLAN_LITE, is_active=True).first()
        if plan:
            UserSubscription.objects.get_or_create(user=user, defaults={"plan": plan})
        refresh = RefreshToken.for_user(user)
        return Response(
            {
                "user": UserSerializer(user).data,
                "refresh": str(refresh),
                "access": str(refresh.access_token),
            },
            status=status.HTTP_201_CREATED,
        )


class MeView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        return Response(UserSerializer(request.user).data)

----- END FILE: apps/accounts/views.py -----

----- BEGIN FILE: apps/agenda/admin.py -----
from django.contrib import admin

from agenda.models import CalendarEvent, ReminderRule


@admin.register(CalendarEvent)
class CalendarEventAdmin(admin.ModelAdmin):
    list_display = ("title", "user", "event_type", "start_at")
    list_filter = ("event_type",)
    search_fields = ("title", "user__email")


@admin.register(ReminderRule)
class ReminderRuleAdmin(admin.ModelAdmin):
    list_display = ("user", "target_type", "remind_before_minutes", "is_active")
    list_filter = ("target_type", "is_active")

----- END FILE: apps/agenda/admin.py -----

----- BEGIN FILE: apps/agenda/apps.py -----
from django.apps import AppConfig


class AgendaConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'agenda'

----- END FILE: apps/agenda/apps.py -----

----- BEGIN FILE: apps/agenda/migrations/0001_initial.py -----
# Generated by Django 4.2.11 on 2026-01-28 13:35

from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
        ('planner', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='ReminderRule',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('target_type', models.CharField(choices=[('TASK', 'Task'), ('EVENT', 'Event')], max_length=10)),
                ('remind_before_minutes', models.PositiveIntegerField()),
                ('channels', models.JSONField(default=list)),
                ('is_active', models.BooleanField(default=True)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='reminder_rules', to=settings.AUTH_USER_MODEL)),
            ],
        ),
        migrations.CreateModel(
            name='CalendarEvent',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=200)),
                ('event_type', models.CharField(choices=[('PROVA', 'Prova'), ('ENTREGA', 'Entrega'), ('APRESENTACAO', 'Apresentacao'), ('AULA_IMPORTANTE', 'Aula importante'), ('OUTRO', 'Outro')], max_length=20)),
                ('start_at', models.DateTimeField()),
                ('end_at', models.DateTimeField(blank=True, null=True)),
                ('notes', models.TextField(blank=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('related_task', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='events', to='planner.task')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='events', to=settings.AUTH_USER_MODEL)),
            ],
        ),
    ]

----- END FILE: apps/agenda/migrations/0001_initial.py -----

----- BEGIN FILE: apps/agenda/migrations/0002_alter_calendarevent_event_type_and_more.py -----
# Generated by Django 6.0.1 on 2026-02-02 15:01

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('agenda', '0001_initial'),
    ]

    operations = [
        migrations.AlterField(
            model_name='calendarevent',
            name='event_type',
            field=models.CharField(choices=[('PROVA', 'Prova'), ('ENTREGA', 'Entrega'), ('APRESENTACAO', 'Apresentacao'), ('AULA_IMPORTANTE', 'Aula importante'), ('REUNIAO_GRUPO', 'Reuniao em grupo'), ('REUNIAO_PROFESSORES', 'Reuniao com professores'), ('ESTUDAR_FACULDADE', 'Estudar na faculdade'), ('OUTRO', 'Outro')], max_length=20),
        ),
        migrations.AlterField(
            model_name='reminderrule',
            name='target_type',
            field=models.CharField(choices=[('TASK', 'Tarefa'), ('EVENT', 'Evento')], max_length=10),
        ),
    ]

----- END FILE: apps/agenda/migrations/0002_alter_calendarevent_event_type_and_more.py -----

----- BEGIN FILE: apps/agenda/models.py -----
from django.conf import settings
from django.db import models

from planner.models import Task
from utils.constants import EVENT_TYPE_CHOICES, REMINDER_TARGET_CHOICES


class CalendarEvent(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name="events")
    title = models.CharField(max_length=200)
    event_type = models.CharField(max_length=20, choices=EVENT_TYPE_CHOICES)
    start_at = models.DateTimeField()
    end_at = models.DateTimeField(null=True, blank=True)
    related_task = models.ForeignKey(Task, on_delete=models.SET_NULL, null=True, blank=True, related_name="events")
    notes = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.title


class ReminderRule(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name="reminder_rules")
    target_type = models.CharField(max_length=10, choices=REMINDER_TARGET_CHOICES)
    remind_before_minutes = models.PositiveIntegerField()
    channels = models.JSONField(default=list)
    is_active = models.BooleanField(default=True)

    def __str__(self):
        return f"{self.user.email} - {self.target_type}"

----- END FILE: apps/agenda/models.py -----

----- BEGIN FILE: apps/agenda/serializers.py -----
from rest_framework import serializers

from agenda.models import CalendarEvent, ReminderRule


class CalendarEventSerializer(serializers.ModelSerializer):
    class Meta:
        model = CalendarEvent
        fields = (
            "id",
            "title",
            "event_type",
            "start_at",
            "end_at",
            "related_task",
            "notes",
            "created_at",
        )
        read_only_fields = ("id", "created_at")


class ReminderRuleSerializer(serializers.ModelSerializer):
    class Meta:
        model = ReminderRule
        fields = ("id", "target_type", "remind_before_minutes", "channels", "is_active")
        read_only_fields = ("id",)

----- END FILE: apps/agenda/serializers.py -----

----- BEGIN FILE: apps/agenda/tests.py -----
from datetime import date

from django.contrib.auth import get_user_model
from rest_framework.test import APITestCase
from rest_framework_simplejwt.tokens import RefreshToken

from billing.models import Plan, UserSubscription
from utils.constants import FEATURE_IN_APP_REMINDERS, FEATURE_PLANNER_BASIC, PLAN_LITE

User = get_user_model()


class ReminderGenerationTests(APITestCase):
    def setUp(self):
        self.user = User.objects.create_user(email="agenda@example.com", name="Agenda", password="pass12345")
        plan, _ = Plan.objects.get_or_create(
            code=PLAN_LITE,
            defaults={
                "name": "Lite",
                "features": [FEATURE_PLANNER_BASIC, FEATURE_IN_APP_REMINDERS],
                "is_active": True,
            },
        )
        UserSubscription.objects.create(user=self.user, plan=plan)
        refresh = RefreshToken.for_user(self.user)
        self.client.credentials(HTTP_AUTHORIZATION=f"Bearer {refresh.access_token}")

    def test_task_create_and_generate_reminders(self):
        task_payload = {
            "title": "Trabalho",
            "description": "Entrega final",
            "due_date": date.today().isoformat(),
            "stress_level": 3,
            "status": "TODO",
        }
        task_response = self.client.post("/api/planner/tasks/", task_payload, format="json")
        self.assertEqual(task_response.status_code, 201)

        rule_payload = {
            "target_type": "TASK",
            "remind_before_minutes": 60,
            "channels": ["EMAIL"],
            "is_active": True,
        }
        rule_response = self.client.post("/api/agenda/reminder-rules/", rule_payload, format="json")
        self.assertEqual(rule_response.status_code, 201)

        generate_response = self.client.post("/api/agenda/generate-reminders/", {}, format="json")
        self.assertEqual(generate_response.status_code, 200)
        self.assertIn("created", generate_response.data)

----- END FILE: apps/agenda/tests.py -----

----- BEGIN FILE: apps/agenda/urls.py -----
from django.urls import path
from rest_framework.routers import DefaultRouter

from agenda.views import CalendarEventViewSet, GenerateRemindersView, AgendaWeekView, ReminderRuleViewSet

router = DefaultRouter()
router.register(r"events", CalendarEventViewSet, basename="events")
router.register(r"reminder-rules", ReminderRuleViewSet, basename="reminder-rules")

urlpatterns = router.urls + [
    path("week/", AgendaWeekView.as_view(), name="agenda-week"),
    path("generate-reminders/", GenerateRemindersView.as_view(), name="agenda-generate-reminders"),
]

----- END FILE: apps/agenda/urls.py -----

----- BEGIN FILE: apps/agenda/views.py -----
from datetime import datetime, time, timedelta

from django.utils import timezone
from rest_framework import permissions, status, viewsets
from rest_framework.response import Response
from rest_framework.views import APIView

from agenda.models import CalendarEvent, ReminderRule
from agenda.serializers import CalendarEventSerializer, ReminderRuleSerializer
from notifications.models import NotificationQueue
from notifications.services.reminder_queue import create_notifications_for_user
from planner.models import Task
from utils.constants import (
    CHANNEL_EMAIL,
    FEATURE_AGENDA_BASIC,
    FEATURE_IN_APP_REMINDERS,
    NOTIF_PENDING,
    REMINDER_TARGET_EVENT,
    REMINDER_TARGET_TASK,
)
from utils.features import require_feature
from utils.gating import gate_generate_reminders


class CalendarEventViewSet(viewsets.ModelViewSet):
    serializer_class = CalendarEventSerializer
    permission_classes = [permissions.IsAuthenticated]

    def initial(self, request, *args, **kwargs):
        require_feature(request.user, FEATURE_AGENDA_BASIC)
        return super().initial(request, *args, **kwargs)

    def get_queryset(self):
        return CalendarEvent.objects.filter(user=self.request.user).order_by("start_at")

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)


class ReminderRuleViewSet(viewsets.ModelViewSet):
    serializer_class = ReminderRuleSerializer
    permission_classes = [permissions.IsAuthenticated]

    def initial(self, request, *args, **kwargs):
        require_feature(request.user, FEATURE_IN_APP_REMINDERS)
        return super().initial(request, *args, **kwargs)

    def get_queryset(self):
        return ReminderRule.objects.filter(user=self.request.user)

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)


class AgendaWeekView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        require_feature(request.user, FEATURE_AGENDA_BASIC)
        now = timezone.now()
        start_of_week = now - timedelta(days=now.weekday())
        end_of_week = start_of_week + timedelta(days=6)
        events = CalendarEvent.objects.filter(
            user=request.user,
            start_at__date__gte=start_of_week.date(),
            start_at__date__lte=end_of_week.date(),
        ).order_by("start_at")
        return Response(CalendarEventSerializer(events, many=True).data)


class GenerateRemindersView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def post(self, request):
        require_feature(request.user, FEATURE_IN_APP_REMINDERS)
        allowed, message = gate_generate_reminders(request.user)
        if not allowed:
            return Response({"detail": message}, status=status.HTTP_403_FORBIDDEN)

        # Bloco: Geracao de lembretes para usuario
        created = create_notifications_for_user(request.user)
        return Response({"created": created})

----- END FILE: apps/agenda/views.py -----

----- BEGIN FILE: apps/analytics/admin.py -----
from django.contrib import admin

# No models to register for MVP.

----- END FILE: apps/analytics/admin.py -----

----- BEGIN FILE: apps/analytics/apps.py -----
from django.apps import AppConfig


class AnalyticsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'analytics'

----- END FILE: apps/analytics/apps.py -----

----- BEGIN FILE: apps/analytics/management/commands/seed_demo_data.py -----
from datetime import date, timedelta

from django.core.management.base import BaseCommand
from django.utils import timezone

from agenda.models import CalendarEvent, ReminderRule
from billing.models import Plan, UserSubscription
from content.models import GuidedContent
from mood.models import MoodEntry
from planner.models import Task
from semester.models import Assessment, Course, Semester
from utils.constants import (
    CONTENT_ANTI_PROCRASTINACAO,
    CONTENT_FOCO,
    CONTENT_PRE_PROVA,
    EVENT_ENTREGA,
    EVENT_PROVA,
    MOOD_BAD,
    MOOD_GOOD,
    MOOD_OK,
    MOOD_VERY_GOOD,
    PLAN_LITE,
)
from django.contrib.auth import get_user_model


class Command(BaseCommand):
    help = "Cria dados de exemplo para o MVP"

    def add_arguments(self, parser):
        parser.add_argument("--email", help="Email do usuario para popular dados")

    def handle(self, *args, **options):
        User = get_user_model()
        email = options.get("email")
        if email:
            user = User.objects.filter(email=email).first()
            if not user:
                self.stdout.write(self.style.ERROR("Usuario nao encontrado."))
                return
        else:
            user = User.objects.first()
            if not user:
                self.stdout.write(self.style.ERROR("Nenhum usuario encontrado."))
                return

        plan = Plan.objects.filter(code=PLAN_LITE).first()
        if plan:
            UserSubscription.objects.get_or_create(user=user, defaults={"plan": plan})

        MoodEntry.objects.get_or_create(user=user, mood=MOOD_OK, defaults={"notes": "Inicio do semestre"})
        MoodEntry.objects.get_or_create(user=user, mood=MOOD_GOOD, defaults={"notes": "Boa semana"})
        MoodEntry.objects.get_or_create(user=user, mood=MOOD_BAD, defaults={"notes": "Cansaco"})
        MoodEntry.objects.get_or_create(user=user, mood=MOOD_VERY_GOOD, defaults={"notes": "Semana excelente"})

        Task.objects.get_or_create(
            user=user,
            title="Trabalho final",
            defaults={
                "description": "Entrega da disciplina X",
                "due_date": date.today() + timedelta(days=10),
                "stress_level": 3,
                "status": "TODO",
            },
        )
        Task.objects.get_or_create(
            user=user,
            title="Leitura cap. 3",
            defaults={
                "description": "Revisao para prova",
                "due_date": date.today() + timedelta(days=5),
                "stress_level": 2,
                "status": "DOING",
            },
        )
        Task.objects.get_or_create(
            user=user,
            title="Lista de exercicios",
            defaults={
                "description": "Praticar conteudos de logica",
                "due_date": date.today() + timedelta(days=3),
                "stress_level": 2,
                "status": "TODO",
            },
        )

        semester, _ = Semester.objects.get_or_create(
            user=user,
            name="2026.1",
            defaults={
                "start_date": date.today() - timedelta(days=20),
                "end_date": date.today() + timedelta(days=120),
            },
        )

        course_math, _ = Course.objects.get_or_create(
            semester=semester,
            title="Matematica Discreta",
            defaults={"teacher": "Prof. Silva", "credits": 4},
        )
        course_alg, _ = Course.objects.get_or_create(
            semester=semester,
            title="Algoritmos I",
            defaults={"teacher": "Prof. Souza", "credits": 4},
        )
        course_db, _ = Course.objects.get_or_create(
            semester=semester,
            title="Banco de Dados",
            defaults={"teacher": "Profa. Carla", "credits": 4},
        )

        Assessment.objects.get_or_create(
            course=course_math,
            title="Prova 1",
            defaults={"score": 7.5, "max_score": 10, "weight": 1, "date": date.today() + timedelta(days=7)},
        )
        Assessment.objects.get_or_create(
            course=course_math,
            title="Trabalho 1",
            defaults={"score": 8.0, "max_score": 10, "weight": 1, "date": date.today() + timedelta(days=14)},
        )
        Assessment.objects.get_or_create(
            course=course_alg,
            title="Trabalho 1",
            defaults={"score": 8.0, "max_score": 10, "weight": 1, "date": date.today() + timedelta(days=12)},
        )
        Assessment.objects.get_or_create(
            course=course_db,
            title="Prova 1",
            defaults={"score": 6.5, "max_score": 10, "weight": 1, "date": date.today() + timedelta(days=9)},
        )

        CalendarEvent.objects.get_or_create(
            user=user,
            title="Entrega Trabalho Final",
            defaults={"event_type": EVENT_ENTREGA, "start_at": timezone.now() + timedelta(days=9)},
        )
        CalendarEvent.objects.get_or_create(
            user=user,
            title="Prova Matematica",
            defaults={"event_type": EVENT_PROVA, "start_at": timezone.now() + timedelta(days=7)},
        )
        CalendarEvent.objects.get_or_create(
            user=user,
            title="Prova Banco de Dados",
            defaults={"event_type": EVENT_PROVA, "start_at": timezone.now() + timedelta(days=9)},
        )

        ReminderRule.objects.get_or_create(
            user=user,
            target_type="TASK",
            defaults={"remind_before_minutes": 1440, "channels": ["EMAIL"], "is_active": True},
        )

        GuidedContent.objects.get_or_create(
            title="Respiracao pre-prova",
            defaults={
                "category": CONTENT_PRE_PROVA,
                "duration_minutes": 8,
                "body_text": "Exercicio guiado de respiracao para antes da prova.",
                "is_premium": False,
            },
        )
        GuidedContent.objects.get_or_create(
            title="Anti-procrastinacao em 10 minutos",
            defaults={
                "category": CONTENT_ANTI_PROCRASTINACAO,
                "duration_minutes": 10,
                "body_text": "Passos curtos para iniciar tarefas e manter o ritmo.",
                "is_premium": False,
            },
        )
        GuidedContent.objects.get_or_create(
            title="Foco profundo 25min",
            defaults={
                "category": CONTENT_FOCO,
                "duration_minutes": 25,
                "body_text": "Sessao guiada de foco com pausas conscientes.",
                "is_premium": True,
            },
        )

        self.stdout.write(self.style.SUCCESS("seed_demo_data: ok"))

----- END FILE: apps/analytics/management/commands/seed_demo_data.py -----

----- BEGIN FILE: apps/analytics/models.py -----
from django.db import models

# Intencionalmente vazio para o MVP.

----- END FILE: apps/analytics/models.py -----

----- BEGIN FILE: apps/analytics/urls.py -----
from django.urls import path

from analytics.views import DashboardView, SemesterAnalyticsView

urlpatterns = [
    path("dashboard/", DashboardView.as_view(), name="analytics-dashboard"),
    path("semester/<int:semester_id>/", SemesterAnalyticsView.as_view(), name="analytics-semester"),
]

----- END FILE: apps/analytics/urls.py -----

----- BEGIN FILE: apps/analytics/views.py -----
from django.shortcuts import get_object_or_404
from django.utils import timezone
from rest_framework import permissions, status
from rest_framework.response import Response
from rest_framework.views import APIView

from agenda.models import CalendarEvent
from mood.models import MoodEntry
from planner.models import Task
from semester.models import Semester
from utils.constants import FEATURE_DASHBOARD_BASIC, FEATURE_REPORTS_ADVANCED, SEMESTER_ACTIVE
from utils.features import has_feature, require_feature


class DashboardView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        require_feature(request.user, FEATURE_DASHBOARD_BASIC)
        now = timezone.now()
        tasks = Task.objects.filter(user=request.user)
        events = CalendarEvent.objects.filter(user=request.user, start_at__gte=now)
        moods = MoodEntry.objects.filter(user=request.user)
        active_semester = Semester.objects.filter(user=request.user, status=SEMESTER_ACTIVE).first()
        return Response(
            {
                "tasks": {
                    "todo": tasks.filter(status="TODO").count(),
                    "doing": tasks.filter(status="DOING").count(),
                    "done": tasks.filter(status="DONE").count(),
                },
                "upcoming_events": events.count(),
                "mood_entries": moods.count(),
                "active_semester": active_semester.name if active_semester else None,
            }
        )


class SemesterAnalyticsView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request, semester_id):
        if not has_feature(request.user, FEATURE_REPORTS_ADVANCED):
            return Response({"detail": "Plano atual nao permite analytics avancado."}, status=status.HTTP_403_FORBIDDEN)
        semester = get_object_or_404(Semester, pk=semester_id, user=request.user)
        courses = semester.courses.all()
        return Response(
            {
                "semester": semester.name,
                "courses": [
                    {
                        "title": course.title,
                        "status": course.status,
                        "final_grade": course.final_grade,
                    }
                    for course in courses
                ],
            }
        )

----- END FILE: apps/analytics/views.py -----

----- BEGIN FILE: apps/billing/admin.py -----
from django.contrib import admin

from billing.models import Plan, UserSubscription


@admin.register(Plan)
class PlanAdmin(admin.ModelAdmin):
    list_display = ("code", "name", "is_active")
    list_filter = ("is_active",)


@admin.register(UserSubscription)
class UserSubscriptionAdmin(admin.ModelAdmin):
    list_display = ("user", "plan", "is_active", "started_at")
    list_filter = ("is_active", "plan")

----- END FILE: apps/billing/admin.py -----

----- BEGIN FILE: apps/billing/apps.py -----
from django.apps import AppConfig
from django.db.models.signals import post_migrate


class BillingConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'billing'

    def ready(self):
        from billing.signals import seed_plans

        post_migrate.connect(seed_plans, sender=self)

----- END FILE: apps/billing/apps.py -----

----- BEGIN FILE: apps/billing/migrations/0001_initial.py -----
# Generated by Django 4.2.11 on 2026-01-28 13:35

from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Plan',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('code', models.CharField(choices=[('LITE', 'Lite'), ('PRO', 'Pro')], max_length=10, unique=True)),
                ('name', models.CharField(max_length=100)),
                ('description', models.TextField(blank=True)),
                ('features', models.JSONField(default=list)),
                ('is_active', models.BooleanField(default=True)),
            ],
        ),
        migrations.CreateModel(
            name='UserSubscription',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('started_at', models.DateTimeField(auto_now_add=True)),
                ('is_active', models.BooleanField(default=True)),
                ('plan', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, to='billing.plan')),
                ('user', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='subscription', to=settings.AUTH_USER_MODEL)),
            ],
        ),
    ]

----- END FILE: apps/billing/migrations/0001_initial.py -----

----- BEGIN FILE: apps/billing/models.py -----
from django.conf import settings
from django.db import models

from utils.constants import PLAN_CHOICES, PLAN_LITE


class Plan(models.Model):
    code = models.CharField(max_length=10, choices=PLAN_CHOICES, unique=True)
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True)
    features = models.JSONField(default=list)
    is_active = models.BooleanField(default=True)

    def __str__(self):
        return f"{self.code}"

    @staticmethod
    def default_lite_features():
        return [
            "MOOD_BASIC",
            "POMODORO_BASIC",
            "PLANNER_BASIC",
            "AGENDA_BASIC",
            "IN_APP_REMINDERS",
            "DASHBOARD_BASIC",
            "CONTENT_LIMITED",
        ]

    @staticmethod
    def default_pro_features():
        return Plan.default_lite_features() + [
            "EMAIL_NOTIFICATIONS",
            "REPORTS_ADVANCED",
            "SEMESTER_SUMMARY",
            "COACH_ADVANCED",
            "CONTENT_FULL",
        ]


class UserSubscription(models.Model):
    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name="subscription")
    plan = models.ForeignKey(Plan, on_delete=models.PROTECT)
    started_at = models.DateTimeField(auto_now_add=True)
    is_active = models.BooleanField(default=True)

    def __str__(self):
        return f"{self.user.email} -> {self.plan.code if self.plan else PLAN_LITE}"

----- END FILE: apps/billing/models.py -----

----- BEGIN FILE: apps/billing/serializers.py -----
from rest_framework import serializers

from billing.models import Plan, UserSubscription


class PlanSerializer(serializers.ModelSerializer):
    class Meta:
        model = Plan
        fields = ("code", "name", "description", "features")


class UserSubscriptionSerializer(serializers.ModelSerializer):
    plan = PlanSerializer()

    class Meta:
        model = UserSubscription
        fields = ("plan", "started_at", "is_active")


class SetPlanSerializer(serializers.Serializer):
    user_id = serializers.IntegerField()
    plan_code = serializers.CharField()

----- END FILE: apps/billing/serializers.py -----

----- BEGIN FILE: apps/billing/signals.py -----
from django.db import transaction

from billing.models import Plan
from utils.constants import (
    FEATURE_AGENDA_BASIC,
    FEATURE_COACH_ADVANCED,
    FEATURE_CONTENT_FULL,
    FEATURE_CONTENT_LIMITED,
    FEATURE_DASHBOARD_BASIC,
    FEATURE_EMAIL_NOTIFICATIONS,
    FEATURE_IN_APP_REMINDERS,
    FEATURE_MOOD_BASIC,
    FEATURE_PLANNER_BASIC,
    FEATURE_POMODORO_BASIC,
    FEATURE_REPORTS_ADVANCED,
    FEATURE_SEMESTER_SUMMARY,
    PLAN_LITE,
    PLAN_PRO,
)


def seed_plans(sender, **kwargs):
    with transaction.atomic():
        Plan.objects.get_or_create(
            code=PLAN_LITE,
            defaults={
                "name": "Lite",
                "description": "Plano basico para organizacao e bem-estar.",
                "features": [
                    FEATURE_MOOD_BASIC,
                    FEATURE_POMODORO_BASIC,
                    FEATURE_PLANNER_BASIC,
                    FEATURE_AGENDA_BASIC,
                    FEATURE_IN_APP_REMINDERS,
                    FEATURE_DASHBOARD_BASIC,
                    FEATURE_CONTENT_LIMITED,
                ],
                "is_active": True,
            },
        )
        Plan.objects.get_or_create(
            code=PLAN_PRO,
            defaults={
                "name": "Pro",
                "description": "Plano completo com notificacoes e relatorios.",
                "features": [
                    FEATURE_MOOD_BASIC,
                    FEATURE_POMODORO_BASIC,
                    FEATURE_PLANNER_BASIC,
                    FEATURE_AGENDA_BASIC,
                    FEATURE_IN_APP_REMINDERS,
                    FEATURE_DASHBOARD_BASIC,
                    FEATURE_CONTENT_LIMITED,
                    FEATURE_EMAIL_NOTIFICATIONS,
                    FEATURE_REPORTS_ADVANCED,
                    FEATURE_SEMESTER_SUMMARY,
                    FEATURE_COACH_ADVANCED,
                    FEATURE_CONTENT_FULL,
                ],
                "is_active": True,
            },
        )

----- END FILE: apps/billing/signals.py -----

----- BEGIN FILE: apps/billing/urls.py -----
from django.urls import path

from billing.views import CurrentPlanView, SetPlanView

urlpatterns = [
    path("plan/", CurrentPlanView.as_view(), name="billing-plan"),
    path("set-plan/", SetPlanView.as_view(), name="billing-set-plan"),
]

----- END FILE: apps/billing/urls.py -----

----- BEGIN FILE: apps/billing/views.py -----
from django.contrib.auth import get_user_model
from rest_framework import permissions, status
from rest_framework.response import Response
from rest_framework.views import APIView

from billing.models import Plan, UserSubscription
from billing.serializers import PlanSerializer, SetPlanSerializer, UserSubscriptionSerializer
from utils.constants import PLAN_LITE

User = get_user_model()


class CurrentPlanView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        subscription = UserSubscription.objects.filter(user=request.user, is_active=True).select_related("plan").first()
        if subscription:
            return Response(UserSubscriptionSerializer(subscription).data)
        plan = Plan.objects.filter(code=PLAN_LITE, is_active=True).first()
        if not plan:
            return Response({"detail": "Plano nao configurado."}, status=status.HTTP_404_NOT_FOUND)
        return Response({"plan": PlanSerializer(plan).data, "started_at": None, "is_active": False})


class SetPlanView(APIView):
    permission_classes = [permissions.IsAdminUser]

    def post(self, request):
        serializer = SetPlanSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user = User.objects.get(id=serializer.validated_data["user_id"])
        plan = Plan.objects.get(code=serializer.validated_data["plan_code"])
        subscription, _ = UserSubscription.objects.get_or_create(user=user, defaults={"plan": plan})
        subscription.plan = plan
        subscription.is_active = True
        subscription.save()
        return Response(UserSubscriptionSerializer(subscription).data)

----- END FILE: apps/billing/views.py -----

----- BEGIN FILE: apps/brain/admin.py -----
from django.contrib import admin

from brain.models import CategoriaEmocional, GatilhoEmocional, InteracaoAluno, MicroIntervencao, RespostaEmocional


@admin.register(CategoriaEmocional)
class CategoriaEmocionalAdmin(admin.ModelAdmin):
    list_display = ("nome", "slug", "emoji", "ativo")
    list_filter = ("ativo",)
    search_fields = ("nome", "slug")


@admin.register(GatilhoEmocional)
class GatilhoEmocionalAdmin(admin.ModelAdmin):
    list_display = ("categoria", "ativo")
    list_filter = ("ativo", "categoria")
    search_fields = ("palavras_chave", "categoria__nome", "categoria__slug")


@admin.register(RespostaEmocional)
class RespostaEmocionalAdmin(admin.ModelAdmin):
    list_display = ("categoria", "ativo")
    list_filter = ("ativo", "categoria")
    search_fields = ("texto", "categoria__nome", "categoria__slug")


@admin.register(MicroIntervencao)
class MicroIntervencaoAdmin(admin.ModelAdmin):
    list_display = ("nome", "ativo")
    list_filter = ("ativo",)
    search_fields = ("nome", "texto")


@admin.register(InteracaoAluno)
class InteracaoAlunoAdmin(admin.ModelAdmin):
    list_display = ("user", "categoria_detectada", "origem", "created_at")
    list_filter = ("origem", "categoria_detectada", "created_at")
    search_fields = ("user__email", "mensagem_usuario", "resposta_texto")

----- END FILE: apps/brain/admin.py -----

----- BEGIN FILE: apps/brain/apps.py -----
from django.apps import AppConfig


class BrainConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "brain"

----- END FILE: apps/brain/apps.py -----

----- BEGIN FILE: apps/brain/constants.py -----
ANXIETY_KEYWORDS = [
    "ansioso",
    "ansiosa",
    "ancioso",
    "anciosa",
    "ansiedade",
    "nervoso",
    "nervosa",
    "panico",
    "pnico",
    "taquicardia",
    "tremendo",
    "tremor",
    "suando",
    "suor",
    "apreensivo",
    "apreensiva",
]

EXAM_KEYWORDS = [
    "prova",
    "teste",
    "exame",
    "apresentacao",
    "apresentao",
    "seminario",
    "seminrio",
    "avaliacao",
    "avaliao",
    "banca",
    "trabalho",
    "entrega",
]

CONTEXT_MESSAGES = {
    "stress_repeat": [
        "Percebo que isso esta se repetindo. Quer me contar um pouco mais do que esta pesando?",
        "Notei que isso voltou a aparecer. Vamos escolher um passo pequeno para aliviar agora?",
        "Entendi. Isso tem se repetido. Quer que eu te ajude a reduzir a carga em 1 prioridade?",
    ],
    "evolucao_repeat": [
        "Voce esta criando consistencia. Quer definir a proxima meta pequena?",
        "Isso e repeticao do bem: consistencia. Qual a proxima etapa simples?",
        "Voce esta mantendo um bom ritmo. Quer escolher um objetivo de 15 minutos agora?",
    ],
    "stress_to_evolucao": [
        "Olha o progresso ai. Ontem parecia pesado e hoje voce avancou.",
        "Da para ver evolucao. Mesmo com desafios recentes, voce conseguiu avancar.",
        "Isso e um bom sinal: voce saiu do peso e foi para a acao. Parabens pelo passo.",
    ],
    "stress_anxiety": [
        "Ansiedade antes de prova e comum. Quer que eu te guie por 60 segundos para acalmar o corpo?",
        "Entendi. Vamos reduzir a ansiedade agora: respira devagar e me diz de 0 a 10 como esta.",
        "Voce nao esta sozinho nisso. Vamos focar no que esta sob controle: qual assunto voce revisou melhor?",
        "Se a ansiedade estiver alta, a meta agora e estabilizar. Quer uma tecnica rapida de aterramento (5-4-3-2-1)?",
    ],
}

----- END FILE: apps/brain/constants.py -----

----- BEGIN FILE: apps/brain/migrations/0001_initial.py -----
# Generated by Django 6.0.1 on 2026-02-12 13:20

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='CategoriaEmocional',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('nome', models.CharField(max_length=120)),
                ('slug', models.SlugField(unique=True)),
                ('emoji', models.CharField(max_length=10)),
                ('ativo', models.BooleanField(default=True)),
            ],
        ),
        migrations.CreateModel(
            name='MicroIntervencao',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('nome', models.CharField(max_length=120)),
                ('texto', models.TextField()),
                ('ativo', models.BooleanField(default=True)),
            ],
        ),
        migrations.CreateModel(
            name='GatilhoEmocional',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('palavras_chave', models.TextField()),
                ('ativo', models.BooleanField(default=True)),
                ('categoria', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='gatilhos', to='brain.categoriaemocional')),
            ],
        ),
        migrations.CreateModel(
            name='InteracaoAluno',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('mensagem_usuario', models.TextField()),
                ('resposta_texto', models.TextField()),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('origem', models.CharField(default='widget', max_length=40)),
                ('categoria_detectada', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='interacoes', to='brain.categoriaemocional')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='interacoes_brain', to=settings.AUTH_USER_MODEL)),
            ],
        ),
        migrations.CreateModel(
            name='RespostaEmocional',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('texto', models.TextField()),
                ('ativo', models.BooleanField(default=True)),
                ('categoria', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='respostas', to='brain.categoriaemocional')),
            ],
        ),
    ]

----- END FILE: apps/brain/migrations/0001_initial.py -----

----- BEGIN FILE: apps/brain/migrations/0002_seed_initial_data.py -----
# Generated by Codex on 2026-02-12

from django.db import migrations


def seed_brain_initial_data(apps, schema_editor):
    CategoriaEmocional = apps.get_model("brain", "CategoriaEmocional")
    GatilhoEmocional = apps.get_model("brain", "GatilhoEmocional")
    RespostaEmocional = apps.get_model("brain", "RespostaEmocional")
    MicroIntervencao = apps.get_model("brain", "MicroIntervencao")

    categorias_data = [
        {
            "nome": "Stress",
            "slug": "stress",
            "emoji": "",
            "gatilhos": [
                "ansioso,ansiedade,nervoso,prova",
                "sobrecarregado,pressao,prazo,estressado",
            ],
            "resposta": "Percebi sinais de stress. Vamos escolher um unico passo simples para comecar agora?",
        },
        {
            "nome": "Duvida",
            "slug": "duvida",
            "emoji": "",
            "gatilhos": [
                "duvida,nao entendi,nao consigo entender",
                "bloqueio,materia dificil,explicacao",
            ],
            "resposta": "Vamos destravar isso por partes. Qual ponto exato da materia esta confuso neste momento?",
        },
        {
            "nome": "Motivacao baixa",
            "slug": "motivacao_baixa",
            "emoji": "",
            "gatilhos": [
                "desmotivado,sem motivacao,desanimado",
                "procrastinando,sem vontade,nada rende",
            ],
            "resposta": "Quando a motivacao cai, o melhor caminho e reduzir o tamanho do passo. Qual tarefa de 10 minutos voce topa iniciar?",
        },
        {
            "nome": "Cansaco mental",
            "slug": "cansaco_mental",
            "emoji": "",
            "gatilhos": [
                "cansado,exausto,sono,dormi pouco",
                "mente cansada,esgotado,sem energia",
            ],
            "resposta": "Seu corpo esta sinalizando cansaco. Que tal recuperar energia com uma pausa breve e depois retomar com uma tarefa leve?",
        },
        {
            "nome": "Foco alto",
            "slug": "foco_alto",
            "emoji": "",
            "gatilhos": [
                "focado,produtivo,concentrado",
                "animado para estudar,ritmo bom,avancando",
            ],
            "resposta": "Excelente momento de foco. Vamos proteger esse ritmo definindo o proximo bloco de estudo sem interrupcoes?",
        },
    ]

    for item in categorias_data:
        categoria, _created = CategoriaEmocional.objects.update_or_create(
            slug=item["slug"],
            defaults={"nome": item["nome"], "emoji": item["emoji"], "ativo": True},
        )

        RespostaEmocional.objects.update_or_create(
            categoria=categoria,
            texto=item["resposta"],
            defaults={"ativo": True},
        )

        for palavras in item["gatilhos"]:
            GatilhoEmocional.objects.update_or_create(
                categoria=categoria,
                palavras_chave=palavras,
                defaults={"ativo": True},
            )

    micro_intervencoes_data = [
        {"nome": "Beber agua", "texto": "Pare 1 minuto e beba um copo de agua para hidratar e retomar com clareza."},
        {
            "nome": "Respiracao 4-4-4",
            "texto": "Inspire por 4 segundos, segure por 4 segundos e expire por 4 segundos durante 3 ciclos.",
        },
    ]
    for item in micro_intervencoes_data:
        MicroIntervencao.objects.update_or_create(
            nome=item["nome"],
            defaults={"texto": item["texto"], "ativo": True},
        )


def unseed_brain_initial_data(apps, schema_editor):
    CategoriaEmocional = apps.get_model("brain", "CategoriaEmocional")
    MicroIntervencao = apps.get_model("brain", "MicroIntervencao")

    CategoriaEmocional.objects.filter(
        slug__in=["stress", "duvida", "motivacao_baixa", "cansaco_mental", "foco_alto"]
    ).delete()
    MicroIntervencao.objects.filter(nome__in=["Beber agua", "Respiracao 4-4-4"]).delete()


class Migration(migrations.Migration):
    dependencies = [
        ("brain", "0001_initial"),
    ]

    operations = [
        migrations.RunPython(seed_brain_initial_data, unseed_brain_initial_data),
    ]

----- END FILE: apps/brain/migrations/0002_seed_initial_data.py -----

----- BEGIN FILE: apps/brain/migrations/0003_seed_social_category.py -----
# Generated by Codex on 2026-02-12

from django.db import migrations


def seed_social_category(apps, schema_editor):
    CategoriaEmocional = apps.get_model("brain", "CategoriaEmocional")
    GatilhoEmocional = apps.get_model("brain", "GatilhoEmocional")
    RespostaEmocional = apps.get_model("brain", "RespostaEmocional")

    categoria_social, _created = CategoriaEmocional.objects.update_or_create(
        slug="social",
        defaults={"nome": "Social", "emoji": "", "ativo": True},
    )

    gatilhos = [
        "obrigado",
        "obrigada",
        "valeu",
        "gratido",
        "agradecido",
    ]
    for gatilho in gatilhos:
        GatilhoEmocional.objects.update_or_create(
            categoria=categoria_social,
            palavras_chave=gatilho,
            defaults={"ativo": True},
        )

    respostas = [
        "Fico feliz em ajudar ",
        "Sempre que precisar, estou aqui.",
        "Conta comigo para o que precisar.",
        " muito bom saber que estou ajudando.",
    ]
    for texto in respostas:
        RespostaEmocional.objects.update_or_create(
            categoria=categoria_social,
            texto=texto,
            defaults={"ativo": True},
        )


def unseed_social_category(apps, schema_editor):
    CategoriaEmocional = apps.get_model("brain", "CategoriaEmocional")
    CategoriaEmocional.objects.filter(slug="social").delete()


class Migration(migrations.Migration):
    dependencies = [
        ("brain", "0002_seed_initial_data"),
    ]

    operations = [
        migrations.RunPython(seed_social_category, unseed_social_category),
    ]

----- END FILE: apps/brain/migrations/0003_seed_social_category.py -----

----- BEGIN FILE: apps/brain/migrations/0004_expand_respostas_categorias.py -----
# Generated by Codex on 2026-02-12

from django.db import migrations


CATEGORY_RESPONSES = {
    "stress": [
        "Entendi. Vamos reduzir isso: qual e a menor parte que voce consegue fazer agora?",
        "Respira um pouco. O que esta te pressionando mais hoje?",
        "Se parecer demais, a gente escolhe so 1 prioridade para hoje.",
        "Vamos com calma: 10 minutos agora ja contam como progresso.",
    ],
    "duvida": [
        "Tudo bem ter duvida. Qual parte ficou mais confusa?",
        "Me diga o tema e eu organizo em passos simples.",
        "O que voce entendeu ate aqui? Mesmo que seja pouco.",
        "Quer um exemplo pratico para destravar esse conteudo?",
    ],
    "motivacao_baixa": [
        "Vamos so comecar: 15 minutos e pronto. Depois voce decide se continua.",
        "Escolhe uma tarefa pequena. O objetivo e ritmo, nao perfeicao.",
        "Quer que eu te ajude a escolher a tarefa mais facil para destravar?",
        "Voce nao precisa render tudo hoje. So precisa dar o primeiro passo.",
    ],
    "cansaco_mental": [
        "Parece cansaco mental. Que tal uma pausa curta antes de continuar?",
        "Vamos reduzir a carga: escolha algo leve e rapido agora.",
        "Se estiver pesado, da para dividir a tarefa em duas partes menores.",
        "Me diz como voce esta agora de 0 a 10, so para eu ajustar melhor.",
    ],
    "foco_alto": [
        "Otimo! Quer aproveitar e atacar a tarefa mais dificil agora?",
        "Perfeito. Qual e a prioridade #1 para concluir hoje?",
        "Se o foco esta alto, da para adiantar uma etapa e ganhar folga depois.",
        "Bora transformar esse foco em resultado: qual meta para a proxima 1 hora?",
    ],
}


def seed_expand_category_replies(apps, schema_editor):
    CategoriaEmocional = apps.get_model("brain", "CategoriaEmocional")
    RespostaEmocional = apps.get_model("brain", "RespostaEmocional")

    for slug, responses in CATEGORY_RESPONSES.items():
        categoria = CategoriaEmocional.objects.filter(slug=slug).first()
        if not categoria:
            continue

        for text in responses:
            RespostaEmocional.objects.update_or_create(
                categoria=categoria,
                texto=text,
                defaults={"ativo": True},
            )


def unseed_expand_category_replies(apps, schema_editor):
    CategoriaEmocional = apps.get_model("brain", "CategoriaEmocional")
    RespostaEmocional = apps.get_model("brain", "RespostaEmocional")

    for slug, responses in CATEGORY_RESPONSES.items():
        categoria = CategoriaEmocional.objects.filter(slug=slug).first()
        if not categoria:
            continue
        RespostaEmocional.objects.filter(categoria=categoria, texto__in=responses).delete()


class Migration(migrations.Migration):
    dependencies = [
        ("brain", "0003_seed_social_category"),
    ]

    operations = [
        migrations.RunPython(seed_expand_category_replies, unseed_expand_category_replies),
    ]

----- END FILE: apps/brain/migrations/0004_expand_respostas_categorias.py -----

----- BEGIN FILE: apps/brain/migrations/0005_seed_evolucao_category.py -----
# Generated by Codex on 2026-02-12

from django.db import migrations


def seed_evolucao_category(apps, schema_editor):
    CategoriaEmocional = apps.get_model("brain", "CategoriaEmocional")
    GatilhoEmocional = apps.get_model("brain", "GatilhoEmocional")
    RespostaEmocional = apps.get_model("brain", "RespostaEmocional")

    categoria_evolucao, _created = CategoriaEmocional.objects.update_or_create(
        slug="evolucao",
        defaults={"nome": "Evoluo", "emoji": "", "ativo": True},
    )

    gatilhos = [
        "estou melhor",
        "evolui",
        "evolu",
        "melhorei",
        "to indo bem",
        "t indo bem",
        "deu certo",
        "consegui",
        "bati a meta",
        "terminei",
        "orgulhoso",
        "orgulhosa",
    ]
    for palavras_chave in gatilhos:
        GatilhoEmocional.objects.update_or_create(
            categoria=categoria_evolucao,
            palavras_chave=palavras_chave,
            defaults={"ativo": True},
        )

    respostas = [
        "Que boa notcia. Quer me dizer o que voc fez que ajudou a melhorar?",
        "Parabns! Qual foi a parte mais difcil que voc superou?",
        "Isso  progresso real. Quer definir a prxima meta pequena para manter o ritmo?",
        "Muito bom. Quer registrar essa vitria para lembrar nos dias difceis?",
    ]
    for texto in respostas:
        RespostaEmocional.objects.update_or_create(
            categoria=categoria_evolucao,
            texto=texto,
            defaults={"ativo": True},
        )


def unseed_evolucao_category(apps, schema_editor):
    CategoriaEmocional = apps.get_model("brain", "CategoriaEmocional")
    CategoriaEmocional.objects.filter(slug="evolucao").delete()


class Migration(migrations.Migration):
    dependencies = [
        ("brain", "0004_expand_respostas_categorias"),
    ]

    operations = [
        migrations.RunPython(seed_evolucao_category, unseed_evolucao_category),
    ]

----- END FILE: apps/brain/migrations/0005_seed_evolucao_category.py -----

----- BEGIN FILE: apps/brain/migrations/0006_expand_evolucao_girias.py -----
# Generated by Codex on 2026-02-12

from django.db import migrations


def seed_evolucao_slang_triggers(apps, schema_editor):
    CategoriaEmocional = apps.get_model("brain", "CategoriaEmocional")
    GatilhoEmocional = apps.get_model("brain", "GatilhoEmocional")

    categoria = CategoriaEmocional.objects.filter(slug="evolucao").first()
    if not categoria:
        return

    girias = [
        "que massa",
        "show",
        "top",
        "consegui",
    ]
    for palavras_chave in girias:
        GatilhoEmocional.objects.update_or_create(
            categoria=categoria,
            palavras_chave=palavras_chave,
            defaults={"ativo": True},
        )


def unseed_evolucao_slang_triggers(apps, schema_editor):
    CategoriaEmocional = apps.get_model("brain", "CategoriaEmocional")
    GatilhoEmocional = apps.get_model("brain", "GatilhoEmocional")

    categoria = CategoriaEmocional.objects.filter(slug="evolucao").first()
    if not categoria:
        return

    GatilhoEmocional.objects.filter(
        categoria=categoria,
        palavras_chave__in=["que massa", "show", "top", "consegui"],
    ).delete()


class Migration(migrations.Migration):
    dependencies = [
        ("brain", "0005_seed_evolucao_category"),
    ]

    operations = [
        migrations.RunPython(seed_evolucao_slang_triggers, unseed_evolucao_slang_triggers),
    ]

----- END FILE: apps/brain/migrations/0006_expand_evolucao_girias.py -----

----- BEGIN FILE: apps/brain/migrations/0007_expand_evolucao_giria_maravilha.py -----
# Generated by Codex on 2026-02-12

from django.db import migrations


def seed_evolucao_maravilha_trigger(apps, schema_editor):
    CategoriaEmocional = apps.get_model("brain", "CategoriaEmocional")
    GatilhoEmocional = apps.get_model("brain", "GatilhoEmocional")

    categoria = CategoriaEmocional.objects.filter(slug="evolucao").first()
    if not categoria:
        return

    GatilhoEmocional.objects.update_or_create(
        categoria=categoria,
        palavras_chave="maravilha",
        defaults={"ativo": True},
    )


def unseed_evolucao_maravilha_trigger(apps, schema_editor):
    CategoriaEmocional = apps.get_model("brain", "CategoriaEmocional")
    GatilhoEmocional = apps.get_model("brain", "GatilhoEmocional")

    categoria = CategoriaEmocional.objects.filter(slug="evolucao").first()
    if not categoria:
        return

    GatilhoEmocional.objects.filter(categoria=categoria, palavras_chave="maravilha").delete()


class Migration(migrations.Migration):
    dependencies = [
        ("brain", "0006_expand_evolucao_girias"),
    ]

    operations = [
        migrations.RunPython(seed_evolucao_maravilha_trigger, unseed_evolucao_maravilha_trigger),
    ]

----- END FILE: apps/brain/migrations/0007_expand_evolucao_giria_maravilha.py -----

----- BEGIN FILE: apps/brain/models.py -----
from django.conf import settings
from django.db import models


class CategoriaEmocional(models.Model):
    nome = models.CharField(max_length=120)
    slug = models.SlugField(unique=True)
    emoji = models.CharField(max_length=10)
    ativo = models.BooleanField(default=True)

    def __str__(self):
        return self.nome


class GatilhoEmocional(models.Model):
    categoria = models.ForeignKey(CategoriaEmocional, on_delete=models.CASCADE, related_name="gatilhos")
    palavras_chave = models.TextField()
    ativo = models.BooleanField(default=True)

    def __str__(self):
        return f"{self.categoria.slug} - gatilho"


class RespostaEmocional(models.Model):
    categoria = models.ForeignKey(CategoriaEmocional, on_delete=models.CASCADE, related_name="respostas")
    texto = models.TextField()
    ativo = models.BooleanField(default=True)

    def __str__(self):
        return f"{self.categoria.slug} - resposta"


class MicroIntervencao(models.Model):
    nome = models.CharField(max_length=120)
    texto = models.TextField()
    ativo = models.BooleanField(default=True)

    def __str__(self):
        return self.nome


class InteracaoAluno(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name="interacoes_brain")
    mensagem_usuario = models.TextField()
    categoria_detectada = models.ForeignKey(
        CategoriaEmocional,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="interacoes",
    )
    resposta_texto = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    origem = models.CharField(max_length=40, default="widget")

    def __str__(self):
        return f"{self.user_id} - {self.created_at:%Y-%m-%d %H:%M:%S}"

----- END FILE: apps/brain/models.py -----

----- BEGIN FILE: apps/brain/tests.py -----
from unittest.mock import patch
from datetime import timedelta

from django.contrib.auth import get_user_model
from django.utils import timezone
from rest_framework.test import APITestCase
from rest_framework_simplejwt.tokens import RefreshToken

from brain.constants import CONTEXT_MESSAGES
from brain.models import CategoriaEmocional, GatilhoEmocional, InteracaoAluno, MicroIntervencao, RespostaEmocional

User = get_user_model()


class WidgetChatTests(APITestCase):
    def setUp(self):
        self.user = User.objects.create_user(email="brain@example.com", name="Brain", password="pass12345")
        refresh = RefreshToken.for_user(self.user)
        self.client.credentials(HTTP_AUTHORIZATION=f"Bearer {refresh.access_token}")

        self.multi_categoria = CategoriaEmocional.objects.create(nome="Multipla", slug="multipla_teste", emoji="")
        GatilhoEmocional.objects.create(categoria=self.multi_categoria, palavras_chave="zzmulti")
        RespostaEmocional.objects.create(categoria=self.multi_categoria, texto="Resposta A")
        RespostaEmocional.objects.create(categoria=self.multi_categoria, texto="Resposta B")
        RespostaEmocional.objects.create(categoria=self.multi_categoria, texto="Resposta C")

        # Seed inicial deve manter ao menos 2 microintervencoes ativas.
        self.assertGreaterEqual(MicroIntervencao.objects.filter(ativo=True).count(), 2)

    def _create_interacao_with_hours_ago(self, categoria_slug, hours_ago):
        categoria = CategoriaEmocional.objects.get(slug=categoria_slug)
        interaction = InteracaoAluno.objects.create(
            user=self.user,
            mensagem_usuario=f"hist-{categoria_slug}-{hours_ago}",
            categoria_detectada=categoria,
            resposta_texto=f"resp-{categoria_slug}",
            origem="widget",
        )
        timestamp = timezone.now() - timedelta(hours=hours_ago)
        InteracaoAluno.objects.filter(pk=interaction.pk).update(created_at=timestamp)
        interaction.refresh_from_db()
        return interaction

    def _create_interacao_custom(self, categoria_slug, resposta_texto, hours_ago):
        categoria = CategoriaEmocional.objects.get(slug=categoria_slug)
        interaction = InteracaoAluno.objects.create(
            user=self.user,
            mensagem_usuario=f"custom-{categoria_slug}-{hours_ago}",
            categoria_detectada=categoria,
            resposta_texto=resposta_texto,
            origem="widget",
        )
        timestamp = timezone.now() - timedelta(hours=hours_ago)
        InteracaoAluno.objects.filter(pk=interaction.pk).update(created_at=timestamp)
        interaction.refresh_from_db()
        return interaction

    def test_detects_social_category(self):
        response = self.client.post("/api/widget/chat/", {"message": "Tenho muita GRATIDAO pela ajuda!"}, format="json")
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["category"], "social")
        self.assertEqual(response.data["emoji"], "")
        self.assertIn(
            response.data["reply"],
            {
                "Fico feliz em ajudar ",
                "Sempre que precisar, estou aqui.",
                "Conta comigo para o que precisar.",
                " muito bom saber que estou ajudando.",
            },
        )
        self.assertEqual(response.data["micro_interventions"], [])
        self.assertEqual(InteracaoAluno.objects.count(), 1)

    def test_social_message_obrigado_returns_empty_micro_interventions(self):
        response = self.client.post("/api/widget/chat/", {"message": "obrigado"}, format="json")
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["category"], "social")
        self.assertEqual(response.data["emoji"], "")
        self.assertEqual(response.data["micro_interventions"], [])

    def test_detects_evolucao_category(self):
        response = self.client.post("/api/widget/chat/", {"message": "Consegui, to indo bem e evolui"}, format="json")
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["category"], "evolucao")
        self.assertEqual(response.data["emoji"], "")
        self.assertTrue(response.data["reply"])
        self.assertEqual(response.data["micro_interventions"], [])

    def test_detects_evolucao_with_student_slang(self):
        response = self.client.post(
            "/api/widget/chat/",
            {"message": "Que massa, show, top, consegui!"},
            format="json",
        )
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["category"], "evolucao")
        self.assertEqual(response.data["emoji"], "")
        self.assertTrue(response.data["reply"])
        self.assertEqual(response.data["micro_interventions"], [])

    def test_detects_evolucao_with_maravilha_slang(self):
        response = self.client.post(
            "/api/widget/chat/",
            {"message": "Maravilha, hoje mandei bem!"},
            format="json",
        )
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["category"], "evolucao")
        self.assertEqual(response.data["emoji"], "")
        self.assertTrue(response.data["reply"])
        self.assertEqual(response.data["micro_interventions"], [])

    def test_detects_stress_anxiety_before_exam(self):
        response = self.client.post(
            "/api/widget/chat/",
            {"message": "vou fazer uma prova e estou muito ansioso"},
            format="json",
        )
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["category"], "stress")
        self.assertIn(response.data["reply"], CONTEXT_MESSAGES["stress_anxiety"])
        self.assertLessEqual(len(response.data["micro_interventions"]), 1)

    def test_detects_stress_anxiety_general_message(self):
        response = self.client.post(
            "/api/widget/chat/",
            {"message": "o que mais posso fazer pra melhorar minha ansiedade?"},
            format="json",
        )
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["category"], "stress")
        self.assertIn(response.data["reply"], CONTEXT_MESSAGES["stress_anxiety"])
        self.assertLessEqual(len(response.data["micro_interventions"]), 1)

    def test_detects_stress_anxiety_with_common_typo(self):
        response = self.client.post(
            "/api/widget/chat/",
            {"message": "boa tarde, vou fazer uma prova e estou muito ancioso"},
            format="json",
        )
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["category"], "stress")
        self.assertIn(response.data["reply"], CONTEXT_MESSAGES["stress_anxiety"])
        self.assertLessEqual(len(response.data["micro_interventions"]), 1)

    def test_weak_positive_with_negative_context_falls_back_to_stress(self):
        response = self.client.post(
            "/api/widget/chat/",
            {"message": "show, mas estou muito ansioso para a prova"},
            format="json",
        )
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["category"], "stress")

    def test_weak_positive_preserved_when_message_is_positive(self):
        response = self.client.post(
            "/api/widget/chat/",
            {"message": "show, consegui terminar tudo"},
            format="json",
        )
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["category"], "evolucao")

    def test_strong_positive_phrase_remains_evolucao(self):
        response = self.client.post(
            "/api/widget/chat/",
            {"message": "que massa, consegui tirar boa nota"},
            format="json",
        )
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["category"], "evolucao")

    def test_micro_interventions_are_limited_to_one_when_present(self):
        response = self.client.post(
            "/api/widget/chat/",
            {"message": "estou sobrecarregado com prazo e estressado"},
            format="json",
        )
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["category"], "stress")
        self.assertLessEqual(len(response.data["micro_interventions"]), 1)

    def test_micro_intervention_avoids_immediate_repeat_when_multiple_options(self):
        first = self.client.post(
            "/api/widget/chat/",
            {"message": "estou sobrecarregado e estressado"},
            format="json",
        )
        second = self.client.post(
            "/api/widget/chat/",
            {"message": "ainda estou sobrecarregado e estressado"},
            format="json",
        )
        self.assertEqual(first.status_code, 200)
        self.assertEqual(second.status_code, 200)
        self.assertLessEqual(len(first.data["micro_interventions"]), 1)
        self.assertLessEqual(len(second.data["micro_interventions"]), 1)

        if first.data["micro_interventions"] and second.data["micro_interventions"]:
            first_name = first.data["micro_interventions"][0]["nome"]
            second_name = second.data["micro_interventions"][0]["nome"]
            if MicroIntervencao.objects.filter(ativo=True).count() > 1:
                self.assertNotEqual(first_name, second_name)

    def test_contextual_memory_stress_repetition_within_48h(self):
        self._create_interacao_with_hours_ago("stress", 2)
        self._create_interacao_with_hours_ago("stress", 4)
        self._create_interacao_with_hours_ago("stress", 6)

        response = self.client.post(
            "/api/widget/chat/",
            {"message": "Estou muito sobrecarregado e estressado"},
            format="json",
        )
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["category"], "stress")
        self.assertIn(response.data["reply"], CONTEXT_MESSAGES["stress_repeat"])

    def test_contextual_memory_repeated_evolucao_within_48h(self):
        self._create_interacao_with_hours_ago("evolucao", 3)
        self._create_interacao_with_hours_ago("evolucao", 5)

        response = self.client.post(
            "/api/widget/chat/",
            {"message": "Consegui, to indo bem"},
            format="json",
        )
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["category"], "evolucao")
        self.assertIn(response.data["reply"], CONTEXT_MESSAGES["evolucao_repeat"])
        self.assertEqual(response.data["micro_interventions"], [])

    def test_contextual_memory_stress_to_evolucao_within_24h(self):
        self._create_interacao_with_hours_ago("stress", 12)

        response = self.client.post(
            "/api/widget/chat/",
            {"message": "Consegui bater a meta, to indo bem"},
            format="json",
        )
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["category"], "evolucao")
        self.assertIn(response.data["reply"], CONTEXT_MESSAGES["stress_to_evolucao"])
        self.assertEqual(response.data["micro_interventions"], [])

    def test_contextual_memory_ignores_interactions_older_than_48h(self):
        self._create_interacao_with_hours_ago("stress", 50)
        self._create_interacao_with_hours_ago("stress", 60)
        self._create_interacao_with_hours_ago("stress", 70)

        response = self.client.post(
            "/api/widget/chat/",
            {"message": "Estou muito sobrecarregado e estressado"},
            format="json",
        )
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["category"], "stress")
        self.assertNotIn(response.data["reply"], CONTEXT_MESSAGES["stress_repeat"])

    def test_contextual_memory_avoids_immediate_repeat_variant(self):
        repeated_text = CONTEXT_MESSAGES["stress_repeat"][0]
        self._create_interacao_custom("stress", repeated_text, 1)
        self._create_interacao_with_hours_ago("stress", 2)
        self._create_interacao_with_hours_ago("stress", 3)

        response = self.client.post(
            "/api/widget/chat/",
            {"message": "Estou muito sobrecarregado e estressado"},
            format="json",
        )
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["category"], "stress")
        self.assertIn(response.data["reply"], CONTEXT_MESSAGES["stress_repeat"])
        self.assertNotEqual(response.data["reply"], repeated_text)

    def test_long_positive_message_prefers_evolucao_over_stress(self):
        response = self.client.post(
            "/api/widget/chat/",
            {"message": "eu estudei bastante, com bastante foco e consegui tirar uma boa nota na prova"},
            format="json",
        )
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["category"], "evolucao")
        self.assertEqual(response.data["emoji"], "")
        self.assertEqual(response.data["micro_interventions"], [])

    def test_primary_categories_have_at_least_four_active_replies(self):
        category_slugs = ["stress", "duvida", "motivacao_baixa", "cansaco_mental", "foco_alto"]
        for slug in category_slugs:
            categoria = CategoriaEmocional.objects.filter(slug=slug).first()
            self.assertIsNotNone(categoria)
            active_count = RespostaEmocional.objects.filter(categoria=categoria, ativo=True).count()
            self.assertGreaterEqual(active_count, 4)

    def test_evolucao_category_has_at_least_four_active_replies(self):
        categoria = CategoriaEmocional.objects.filter(slug="evolucao").first()
        self.assertIsNotNone(categoria)
        active_count = RespostaEmocional.objects.filter(categoria=categoria, ativo=True).count()
        self.assertGreaterEqual(active_count, 4)

    def test_endpoint_typical_messages_for_primary_categories(self):
        samples = [
            ("stress", "Estou sobrecarregado com prazo"),
            ("duvida", "Nao entendi essa materia"),
            ("motivacao_baixa", "Estou desmotivado hoje"),
            ("cansaco_mental", "Estou esgotado e sem energia"),
            ("foco_alto", "Hoje estou concentrado e produtivo"),
        ]
        for expected_slug, message in samples:
            response = self.client.post("/api/widget/chat/", {"message": message}, format="json")
            self.assertEqual(response.status_code, 200)
            self.assertEqual(response.data["category"], expected_slug)
            self.assertTrue(response.data["reply"])

    def test_scoring_phrase_weight_wins_over_single_word(self):
        phrase_categoria = CategoriaEmocional.objects.create(nome="Score Frase", slug="score_frase_teste", emoji="")
        word_categoria = CategoriaEmocional.objects.create(nome="Score Palavra", slug="score_palavra_teste", emoji="")

        GatilhoEmocional.objects.create(categoria=phrase_categoria, palavras_chave="mega progresso")
        GatilhoEmocional.objects.create(categoria=word_categoria, palavras_chave="mega")

        RespostaEmocional.objects.create(categoria=phrase_categoria, texto="Resposta categoria frase")
        RespostaEmocional.objects.create(categoria=word_categoria, texto="Resposta categoria palavra")

        response = self.client.post("/api/widget/chat/", {"message": "hoje foi mega progresso"}, format="json")
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["category"], "score_frase_teste")
        self.assertEqual(response.data["emoji"], "")
        self.assertTrue(response.data["reply"])

    @patch("brain.views.choose_variant", return_value="Resposta B")
    def test_selects_random_reply_among_category_options(self, choose_variant_mock):
        response = self.client.post("/api/widget/chat/", {"message": "zzmulti agora"}, format="json")
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["category"], "multipla_teste")
        self.assertEqual(response.data["reply"], "Resposta B")
        choose_variant_mock.assert_called()

    @patch("brain.views.choose_variant", return_value="Resposta B")
    def test_avoids_immediate_reply_repetition_for_same_user(self, choose_variant_mock):
        InteracaoAluno.objects.create(
            user=self.user,
            mensagem_usuario="mensagem anterior",
            categoria_detectada=self.multi_categoria,
            resposta_texto="Resposta A",
            origem="widget",
        )

        response = self.client.post("/api/widget/chat/", {"message": "zzmulti novamente"}, format="json")
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["reply"], "Resposta B")
        self.assertNotEqual(response.data["reply"], "Resposta A")
        choose_variant_mock.assert_called()

    @patch("brain.views.random.choice", return_value="Entendi. Me fala um pouco mais para eu poder te ajudar melhor.")
    def test_fallback_returns_null_category_and_no_micro_interventions(self, random_choice_mock):
        response = self.client.post(
            "/api/widget/chat/",
            {"message": "mensagem sem qualquer gatilho conhecido qwerty"},
            format="json",
        )
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["category"], None)
        self.assertEqual(response.data["emoji"], None)
        self.assertEqual(response.data["micro_interventions"], [])
        self.assertEqual(response.data["reply"], "Entendi. Me fala um pouco mais para eu poder te ajudar melhor.")
        random_choice_mock.assert_called()

----- END FILE: apps/brain/tests.py -----

----- BEGIN FILE: apps/brain/urls.py -----
from django.urls import path

from brain.views import WidgetChatView

urlpatterns = [
    path("chat/", WidgetChatView.as_view(), name="widget-chat"),
]

----- END FILE: apps/brain/urls.py -----

----- BEGIN FILE: apps/brain/views.py -----
import re
import random
import unicodedata
from collections import defaultdict
from datetime import timedelta

from django.conf import settings
from django.utils import timezone

from rest_framework import permissions, serializers, status
from rest_framework.authentication import SessionAuthentication
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework_simplejwt.authentication import JWTAuthentication

from brain.constants import ANXIETY_KEYWORDS, CONTEXT_MESSAGES, EXAM_KEYWORDS
from brain.models import GatilhoEmocional, InteracaoAluno, MicroIntervencao, RespostaEmocional


class WidgetChatRequestSerializer(serializers.Serializer):
    message = serializers.CharField(allow_blank=False, trim_whitespace=True)


FALLBACK_REPLIES = [
    "Estou aqui com voce. Quer me contar um pouco mais sobre isso?",
    "Entendi. Me fala um pouco mais para eu poder te ajudar melhor.",
]

CATEGORY_PRIORITY = [
    "evolucao",
    "foco_alto",
    "social",
    "duvida",
    "motivacao_baixa",
    "cansaco_mental",
    "stress",
]

SOCIAL_STRONG_HINTS = ("obrigad", "valeu")
NEGATIVE_KEYWORDS = [
    "ansioso",
    "ansiosa",
    "ansiedade",
    "nervoso",
    "nervosa",
    "cansado",
    "cansada",
    "estressado",
    "estressada",
    "dificil",
    "difcil",
    "medo",
    "preocupado",
    "preocupada",
    "triste",
]
WEAK_POSITIVE_KEYWORDS = [
    "show",
    "top",
    "massa",
]


def choose_variant(options: list[str], last_text: str | None) -> str:
    unique_options = list(dict.fromkeys(options or []))
    if not unique_options:
        return ""
    if last_text in unique_options and len(unique_options) > 1:
        filtered = [text for text in unique_options if text != last_text]
        return random.choice(filtered)
    return random.choice(unique_options)


def _normalize_text(value):
    normalized = unicodedata.normalize("NFD", str(value or "").lower())
    no_accents = "".join(char for char in normalized if unicodedata.category(char) != "Mn")
    no_punctuation = re.sub(r"[^a-z0-9\s]", " ", no_accents)
    return re.sub(r"\s+", " ", no_punctuation).strip()


def _extract_keywords(raw_keywords):
    parts = re.split(r"[,\n;]+", str(raw_keywords or ""))
    cleaned = []
    for part in parts:
        keyword = _normalize_text(part.strip())
        if keyword:
            cleaned.append(keyword)
    return cleaned


def _contains_keyword(message_text, message_words, keyword):
    if not keyword:
        return False
    if " " in keyword:
        return keyword in message_text
    return keyword in message_words


def _has_any_keyword(message_text, keywords):
    if not message_text:
        return False
    message_words = set(message_text.split())
    for raw_keyword in keywords:
        keyword = _normalize_text(raw_keyword)
        if keyword and _contains_keyword(message_text, message_words, keyword):
            return True
    return False


def _detect_categoria(message_text):
    if not message_text:
        return None

    message_words = set(message_text.split())
    has_negative_keywords = _has_any_keyword(message_text, NEGATIVE_KEYWORDS)
    gatilhos = GatilhoEmocional.objects.filter(ativo=True, categoria__ativo=True).select_related("categoria").order_by("id")
    score_by_slug = defaultdict(int)
    category_by_slug = {}

    for gatilho in gatilhos:
        categoria = gatilho.categoria
        slug = categoria.slug
        category_by_slug[slug] = categoria
        keywords = _extract_keywords(gatilho.palavras_chave)
        for keyword in keywords:
            if _contains_keyword(message_text, message_words, keyword):
                if keyword in WEAK_POSITIVE_KEYWORDS and has_negative_keywords:
                    weight = 0
                else:
                    weight = 2 if " " in keyword else 1
                score_by_slug[slug] += weight

    if not score_by_slug:
        return None

    max_score = max(score_by_slug.values())
    if max_score <= 0:
        return None

    top_slugs = [slug for slug, score in score_by_slug.items() if score == max_score]

    # Optional UX rule: social should win ties only for clear/short gratitude signals.
    if "social" in top_slugs and len(top_slugs) > 1:
        is_short_message = len(message_text) <= 40
        has_social_hint = any(hint in message_text for hint in SOCIAL_STRONG_HINTS)
        if not (is_short_message or has_social_hint):
            filtered = [slug for slug in top_slugs if slug != "social"]
            if filtered:
                top_slugs = filtered

    for priority_slug in CATEGORY_PRIORITY:
        if priority_slug in top_slugs:
            return category_by_slug.get(priority_slug)

    chosen_slug = sorted(top_slugs)[0]
    return category_by_slug.get(chosen_slug)


def _pick_category_reply(categoria, last_response_text):
    respostas = list(RespostaEmocional.objects.filter(categoria=categoria, ativo=True).values_list("texto", flat=True))
    if not respostas:
        return None
    return choose_variant(respostas, last_response_text)


def _load_recent_history(user):
    memory_hours = getattr(settings, "BRAIN_MEMORY_HOURS", 48)
    history_limit = getattr(settings, "BRAIN_HISTORY_LIMIT", 10)
    limite_48h = timezone.now() - timedelta(hours=memory_hours)
    return list(
        InteracaoAluno.objects.filter(user=user, created_at__gte=limite_48h)
        .select_related("categoria_detectada")
        .order_by("-created_at")[:history_limit]
    )


def _pick_contextual_reply(categoria, history, now, last_response_text):
    if not categoria:
        return None

    stress_threshold = getattr(settings, "BRAIN_STRESS_REPEAT_THRESHOLD", 3)
    evolucao_threshold = getattr(settings, "BRAIN_EVOLUCAO_REPEAT_THRESHOLD", 2)
    stress_to_evolucao_window = getattr(settings, "BRAIN_STRESS_TO_EVOLUCAO_WINDOW_HOURS", 24)

    current_slug = categoria.slug
    history_slugs = [item.categoria_detectada.slug for item in history if item.categoria_detectada]

    if current_slug == "stress":
        if len(history_slugs) >= stress_threshold and all(slug == "stress" for slug in history_slugs[:stress_threshold]):
            return choose_variant(CONTEXT_MESSAGES["stress_repeat"], last_response_text)
        return None

    if current_slug == "evolucao":
        if len(history_slugs) >= evolucao_threshold and all(
            slug == "evolucao" for slug in history_slugs[:evolucao_threshold]
        ):
            return choose_variant(CONTEXT_MESSAGES["evolucao_repeat"], last_response_text)

        limite_24h = now - timedelta(hours=stress_to_evolucao_window)
        has_recent_stress = any(
            item.categoria_detectada
            and item.categoria_detectada.slug == "stress"
            and item.created_at >= limite_24h
            for item in history
        )
        if has_recent_stress:
            return choose_variant(CONTEXT_MESSAGES["stress_to_evolucao"], last_response_text)

    return None


def _pick_micro_intervention(request, categoria):
    if not categoria or categoria.slug in {"social", "evolucao"}:
        return []

    options = list(MicroIntervencao.objects.filter(ativo=True).order_by("id"))
    if not options:
        return []

    session_key = "brain_last_micro_intervention_name"
    last_micro_name = request.session.get(session_key)

    candidates = options
    if last_micro_name and len(options) > 1:
        filtered = [item for item in options if item.nome != last_micro_name]
        if filtered:
            candidates = filtered

    selected = random.choice(candidates)
    request.session[session_key] = selected.nome
    return [{"nome": selected.nome, "texto": selected.texto}]


class WidgetChatView(APIView):
    authentication_classes = [SessionAuthentication, JWTAuthentication]
    permission_classes = [permissions.IsAuthenticated]

    def post(self, request):
        serializer = WidgetChatRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        mensagem_usuario = serializer.validated_data["message"].strip()
        normalized_message = _normalize_text(mensagem_usuario)
        now = timezone.now()
        last_response_text = (
            InteracaoAluno.objects.filter(user=request.user)
            .order_by("-created_at", "-id")
            .values_list("resposta_texto", flat=True)
            .first()
        )

        categoria = _detect_categoria(normalized_message)
        if categoria:
            reply_text = None
            if categoria.slug == "stress":
                has_anxiety = _has_any_keyword(normalized_message, ANXIETY_KEYWORDS)
                has_exam = _has_any_keyword(normalized_message, EXAM_KEYWORDS)
                if has_anxiety and has_exam:
                    reply_text = choose_variant(CONTEXT_MESSAGES["stress_anxiety"], last_response_text)
                elif has_anxiety:
                    reply_text = choose_variant(CONTEXT_MESSAGES["stress_anxiety"], last_response_text)

            historico = _load_recent_history(request.user)
            if not reply_text:
                reply_text = _pick_contextual_reply(categoria, historico, now, last_response_text)
            if not reply_text:
                reply_text = _pick_category_reply(categoria, last_response_text)
            if not reply_text:
                reply_text = random.choice(FALLBACK_REPLIES)
            payload_micro_intervencoes = _pick_micro_intervention(request, categoria)
        else:
            reply_text = random.choice(FALLBACK_REPLIES)
            payload_micro_intervencoes = []

        InteracaoAluno.objects.create(
            user=request.user,
            mensagem_usuario=mensagem_usuario,
            categoria_detectada=categoria,
            resposta_texto=reply_text,
            origem="widget",
        )

        return Response(
            {
                "reply": reply_text,
                "category": categoria.slug if categoria else None,
                "emoji": categoria.emoji if categoria else None,
                "micro_interventions": payload_micro_intervencoes,
            },
            status=status.HTTP_200_OK,
        )

----- END FILE: apps/brain/views.py -----

----- BEGIN FILE: apps/coach_ai/admin.py -----
from django.contrib import admin

from coach_ai.models import CoachLog


@admin.register(CoachLog)
class CoachLogAdmin(admin.ModelAdmin):
    list_display = ("user", "trigger_type", "created_at")
    list_filter = ("trigger_type",)

----- END FILE: apps/coach_ai/admin.py -----

----- BEGIN FILE: apps/coach_ai/apps.py -----
from django.apps import AppConfig


class CoachAiConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'coach_ai'

----- END FILE: apps/coach_ai/apps.py -----

----- BEGIN FILE: apps/coach_ai/migrations/0001_initial.py -----
# Generated by Django 4.2.11 on 2026-01-28 13:35

from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='CoachLog',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('trigger_type', models.CharField(choices=[('PRAZO_PROXIMO', 'Prazo proximo'), ('ATRASO', 'Atraso'), ('HUMOR_BAIXO', 'Humor baixo'), ('SEMESTRE_CONCLUIDO', 'Semestre concluido'), ('REPROVACAO', 'Reprovacao')], max_length=30)),
                ('suggestion_text', models.TextField()),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='coach_logs', to=settings.AUTH_USER_MODEL)),
            ],
        ),
    ]

----- END FILE: apps/coach_ai/migrations/0001_initial.py -----

----- BEGIN FILE: apps/coach_ai/models.py -----
from django.conf import settings
from django.db import models

from utils.constants import COACH_TRIGGER_CHOICES


class CoachLog(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name="coach_logs")
    trigger_type = models.CharField(max_length=30, choices=COACH_TRIGGER_CHOICES)
    suggestion_text = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.user.email} - {self.trigger_type}"

----- END FILE: apps/coach_ai/models.py -----

----- BEGIN FILE: apps/content/admin.py -----
from django.contrib import admin

from content.models import GuidedContent


@admin.register(GuidedContent)
class GuidedContentAdmin(admin.ModelAdmin):
    list_display = ("title", "category", "duration_minutes", "is_premium")
    list_filter = ("category", "is_premium")

----- END FILE: apps/content/admin.py -----

----- BEGIN FILE: apps/content/apps.py -----
from django.apps import AppConfig


class ContentConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'content'

----- END FILE: apps/content/apps.py -----

----- BEGIN FILE: apps/content/migrations/0001_initial.py -----
# Generated by Django 4.2.11 on 2026-01-28 13:35

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='GuidedContent',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=200)),
                ('category', models.CharField(choices=[('PRE_PROVA', 'Pre-prova'), ('ANTI_PROCRASTINACAO', 'Anti-procrastinacao'), ('FOCO', 'Foco')], max_length=50)),
                ('duration_minutes', models.PositiveIntegerField()),
                ('body_text', models.TextField()),
                ('is_premium', models.BooleanField(default=False)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
            ],
        ),
    ]

----- END FILE: apps/content/migrations/0001_initial.py -----

----- BEGIN FILE: apps/content/models.py -----
from django.db import models

from utils.constants import CONTENT_CATEGORY_CHOICES


class GuidedContent(models.Model):
    title = models.CharField(max_length=200)
    category = models.CharField(max_length=50, choices=CONTENT_CATEGORY_CHOICES)
    duration_minutes = models.PositiveIntegerField()
    body_text = models.TextField()
    is_premium = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.title

----- END FILE: apps/content/models.py -----

----- BEGIN FILE: apps/content/serializers.py -----
from rest_framework import serializers

from content.models import GuidedContent


class GuidedContentSerializer(serializers.ModelSerializer):
    class Meta:
        model = GuidedContent
        fields = ("id", "title", "category", "duration_minutes", "body_text", "is_premium", "created_at")
        read_only_fields = ("id", "created_at")

----- END FILE: apps/content/serializers.py -----

----- BEGIN FILE: apps/content/urls.py -----
from django.urls import path

from content.views import GuidedContentDetailView, GuidedContentListView

urlpatterns = [
    path("guided/", GuidedContentListView.as_view(), name="guided-content"),
    path("guided/<int:pk>/", GuidedContentDetailView.as_view(), name="guided-content-detail"),
]

----- END FILE: apps/content/urls.py -----

----- BEGIN FILE: apps/content/views.py -----
from django.shortcuts import get_object_or_404
from rest_framework import permissions, status
from rest_framework.response import Response
from rest_framework.views import APIView

from content.models import GuidedContent
from content.serializers import GuidedContentSerializer
from utils.constants import FEATURE_CONTENT_FULL, FEATURE_CONTENT_LIMITED
from utils.features import has_feature


class GuidedContentListView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        if not has_feature(request.user, FEATURE_CONTENT_FULL) and not has_feature(request.user, FEATURE_CONTENT_LIMITED):
            return Response({"detail": "Plano atual nao permite conteudos."}, status=status.HTTP_403_FORBIDDEN)
        queryset = GuidedContent.objects.all().order_by("-created_at")
        if not has_feature(request.user, FEATURE_CONTENT_FULL):
            queryset = queryset.filter(is_premium=False)
        return Response(GuidedContentSerializer(queryset, many=True).data)


class GuidedContentDetailView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request, pk):
        content = get_object_or_404(GuidedContent, pk=pk)
        if content.is_premium and not has_feature(request.user, FEATURE_CONTENT_FULL):
            return Response({"detail": "Plano atual nao permite este conteudo."}, status=status.HTTP_403_FORBIDDEN)
        return Response(GuidedContentSerializer(content).data)

----- END FILE: apps/content/views.py -----

----- BEGIN FILE: apps/mood/admin.py -----
from django.contrib import admin

from mood.models import MoodEntry


@admin.register(MoodEntry)
class MoodEntryAdmin(admin.ModelAdmin):
    list_display = ("user", "mood", "created_at")
    list_filter = ("mood",)
    search_fields = ("user__email",)

----- END FILE: apps/mood/admin.py -----

----- BEGIN FILE: apps/mood/apps.py -----
from django.apps import AppConfig


class MoodConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'mood'

----- END FILE: apps/mood/apps.py -----

----- BEGIN FILE: apps/mood/migrations/0001_initial.py -----
# Generated by Django 4.2.11 on 2026-01-28 13:35

from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='MoodEntry',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('mood', models.CharField(choices=[('VERY_BAD', 'Very bad'), ('BAD', 'Bad'), ('OK', 'Ok'), ('GOOD', 'Good'), ('VERY_GOOD', 'Very good')], max_length=20)),
                ('notes', models.TextField(blank=True)),
                ('tags', models.JSONField(default=list)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='mood_entries', to=settings.AUTH_USER_MODEL)),
            ],
        ),
    ]

----- END FILE: apps/mood/migrations/0001_initial.py -----

----- BEGIN FILE: apps/mood/models.py -----
from django.conf import settings
from django.db import models

from utils.constants import MOOD_CHOICES


class MoodEntry(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name="mood_entries")
    mood = models.CharField(max_length=20, choices=MOOD_CHOICES)
    notes = models.TextField(blank=True)
    tags = models.JSONField(default=list)
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.user.email} - {self.mood}"

----- END FILE: apps/mood/models.py -----

----- BEGIN FILE: apps/mood/serializers.py -----
from rest_framework import serializers

from mood.models import MoodEntry


class MoodEntrySerializer(serializers.ModelSerializer):
    class Meta:
        model = MoodEntry
        fields = ("id", "mood", "notes", "tags", "created_at")
        read_only_fields = ("id", "created_at")

----- END FILE: apps/mood/serializers.py -----

----- BEGIN FILE: apps/mood/tests.py -----
from django.contrib.auth import get_user_model
from rest_framework.test import APITestCase
from rest_framework_simplejwt.tokens import RefreshToken

from billing.models import Plan, UserSubscription
from utils.constants import FEATURE_MOOD_BASIC, PLAN_LITE

User = get_user_model()


class MoodEntryTests(APITestCase):
    def setUp(self):
        self.user = User.objects.create_user(email="mood@example.com", name="Mood", password="pass12345")
        plan, _ = Plan.objects.get_or_create(
            code=PLAN_LITE, defaults={"name": "Lite", "features": [FEATURE_MOOD_BASIC], "is_active": True}
        )
        UserSubscription.objects.create(user=self.user, plan=plan)
        refresh = RefreshToken.for_user(self.user)
        self.client.credentials(HTTP_AUTHORIZATION=f"Bearer {refresh.access_token}")

    def test_create_mood_entry(self):
        response = self.client.post("/api/mood/entries/", {"mood": "OK", "notes": "Tudo bem"}, format="json")
        self.assertEqual(response.status_code, 201)

----- END FILE: apps/mood/tests.py -----

----- BEGIN FILE: apps/mood/urls.py -----
from django.urls import path

from mood.views import MoodEntryListCreateView, MoodWeeklySummaryView

urlpatterns = [
    path("entries/", MoodEntryListCreateView.as_view(), name="mood-entries"),
    path("summary/weekly/", MoodWeeklySummaryView.as_view(), name="mood-summary-weekly"),
]

----- END FILE: apps/mood/urls.py -----

----- BEGIN FILE: apps/mood/views.py -----
from datetime import timedelta

from django.utils import timezone
from rest_framework import permissions, status
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.generics import ListCreateAPIView

from mood.models import MoodEntry
from mood.serializers import MoodEntrySerializer
from utils.constants import FEATURE_MOOD_BASIC, MOOD_VERY_BAD
from utils.features import require_feature


class MoodEntryListCreateView(ListCreateAPIView):
    serializer_class = MoodEntrySerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        require_feature(self.request.user, FEATURE_MOOD_BASIC)
        return MoodEntry.objects.filter(user=self.request.user).order_by("-created_at")

    def perform_create(self, serializer):
        require_feature(self.request.user, FEATURE_MOOD_BASIC)
        serializer.save(user=self.request.user)

    def create(self, request, *args, **kwargs):
        response = super().create(request, *args, **kwargs)
        week_ago = timezone.now() - timedelta(days=7)
        very_bad_count = MoodEntry.objects.filter(
            user=request.user, mood=MOOD_VERY_BAD, created_at__gte=week_ago
        ).count()
        if very_bad_count >= 3:
            response.data["wellness_notice"] = (
                "Percebemos humor muito baixo recorrente. Procure apoio profissional."
                " No Brasil, o CVV atende 188 (24h)."
            )
        return response


class MoodWeeklySummaryView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        require_feature(request.user, FEATURE_MOOD_BASIC)
        week_ago = timezone.now() - timedelta(days=7)
        entries = MoodEntry.objects.filter(user=request.user, created_at__gte=week_ago)
        summary = {}
        for mood, _label in MoodEntry._meta.get_field("mood").choices:
            summary[mood] = entries.filter(mood=mood).count()
        return Response({"summary": summary})

----- END FILE: apps/mood/views.py -----

----- BEGIN FILE: apps/notifications/admin.py -----
from django.contrib import admin

from notifications.models import IncomingMessage, NotificationQueue


@admin.register(NotificationQueue)
class NotificationQueueAdmin(admin.ModelAdmin):
    list_display = ("user", "channel", "status", "action_taken", "scheduled_for", "sent_at", "attempts")
    list_filter = ("channel", "status", "action_taken")


@admin.register(IncomingMessage)
class IncomingMessageAdmin(admin.ModelAdmin):
    list_display = ("phone_from", "parsed_action", "received_at", "matched_notification")
    list_filter = ("parsed_action",)

----- END FILE: apps/notifications/admin.py -----

----- BEGIN FILE: apps/notifications/apps.py -----
from django.apps import AppConfig


class NotificationsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'notifications'

----- END FILE: apps/notifications/apps.py -----

----- BEGIN FILE: apps/notifications/management/commands/process_notification_queue.py -----
from django.core.management.base import BaseCommand
from django.core.mail import send_mail
from django.utils import timezone

from accounts.models import UserProfile
from notifications.models import NotificationQueue
from notifications.services.whatsapp_service import normalize_phone, send_whatsapp_message_raw
from utils.constants import (
    CHANNEL_EMAIL,
    CHANNEL_IN_APP,
    CHANNEL_SMS,
    CHANNEL_WHATSAPP,
    NOTIF_FAILED,
    NOTIF_PENDING,
    NOTIF_SENT,
)


class Command(BaseCommand):
    help = "Processa a fila de notificacoes pendentes."

    def handle(self, *args, **options):
        now = timezone.now()
        pending = NotificationQueue.objects.filter(status=NOTIF_PENDING, scheduled_for__lte=now)
        for notification in pending:
            try:
                # Bloco: Contagem de tentativas
                notification.attempts += 1

                if notification.channel == CHANNEL_EMAIL:
                    # Bloco: Envio de email
                    send_mail(notification.title, notification.message, None, [notification.user.email])
                elif notification.channel == CHANNEL_WHATSAPP:
                    # Bloco: Envio de WhatsApp
                    phone = notification.to_phone
                    if not phone:
                        try:
                            phone = notification.user.profile.phone
                        except UserProfile.DoesNotExist:
                            phone = notification.user.phone_number
                    phone = normalize_phone(phone)
                    if not phone:
                        raise RuntimeError("Telefone WhatsApp nao informado.")

                    body = f"{notification.message} [#N{notification.id}]\\nResponda 1 confirmar, 2 adiar 10min, 3 cancelar"
                    response = send_whatsapp_message_raw(phone, body)
                    provider_id = ""
                    if isinstance(response, dict):
                        provider_id = response.get("messages", [{}])[0].get("id", "")
                    if response is None:
                        raise RuntimeError("Falha no envio do WhatsApp.")
                    notification.provider = "META"
                    notification.provider_message_id = provider_id or ""
                    notification.to_phone = phone
                elif notification.channel == CHANNEL_SMS:
                    # Bloco: SMS mock (fallback)
                    notification.provider = "MOCK"
                elif notification.channel == CHANNEL_IN_APP:
                    # Bloco: In-app (sem envio externo)
                    notification.provider = "IN_APP"

                notification.status = NOTIF_SENT
                notification.sent_at = timezone.now()
                notification.last_error = ""
                notification.save()
                self.stdout.write(self.style.SUCCESS(f"Enviado: {notification.id}"))
            except Exception as exc:
                notification.status = NOTIF_FAILED
                notification.last_error = str(exc)
                notification.save()
                self.stdout.write(self.style.ERROR(f"Falhou: {notification.id}"))

----- END FILE: apps/notifications/management/commands/process_notification_queue.py -----

----- BEGIN FILE: apps/notifications/migrations/0001_initial.py -----
# Generated by Django 4.2.11 on 2026-01-28 13:35

from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='NotificationQueue',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('channel', models.CharField(choices=[('EMAIL', 'Email'), ('WHATSAPP', 'WhatsApp'), ('SMS', 'SMS')], max_length=20)),
                ('title', models.CharField(max_length=200)),
                ('message', models.TextField()),
                ('scheduled_for', models.DateTimeField()),
                ('status', models.CharField(choices=[('PENDING', 'Pending'), ('SENT', 'Sent'), ('FAILED', 'Failed')], default='PENDING', max_length=20)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='notifications', to=settings.AUTH_USER_MODEL)),
            ],
        ),
    ]

----- END FILE: apps/notifications/migrations/0001_initial.py -----

----- BEGIN FILE: apps/notifications/migrations/0002_notificationqueue_action_taken_and_more.py -----
# Generated by Django 6.0.1 on 2026-02-02 14:09

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('notifications', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='notificationqueue',
            name='action_taken',
            field=models.CharField(choices=[('NONE', 'None'), ('CONFIRMED', 'Confirmed'), ('DELAYED', 'Delayed'), ('CANCELED', 'Canceled')], default='NONE', max_length=20),
        ),
        migrations.AddField(
            model_name='notificationqueue',
            name='attempts',
            field=models.PositiveIntegerField(default=0),
        ),
        migrations.AddField(
            model_name='notificationqueue',
            name='last_error',
            field=models.TextField(blank=True),
        ),
        migrations.AddField(
            model_name='notificationqueue',
            name='provider',
            field=models.CharField(blank=True, max_length=50),
        ),
        migrations.AddField(
            model_name='notificationqueue',
            name='provider_message_id',
            field=models.CharField(blank=True, max_length=200),
        ),
        migrations.AddField(
            model_name='notificationqueue',
            name='sent_at',
            field=models.DateTimeField(blank=True, null=True),
        ),
        migrations.AddField(
            model_name='notificationqueue',
            name='to_phone',
            field=models.CharField(blank=True, max_length=30),
        ),
        migrations.AlterField(
            model_name='notificationqueue',
            name='channel',
            field=models.CharField(choices=[('IN_APP', 'In app'), ('EMAIL', 'Email'), ('WHATSAPP', 'WhatsApp'), ('SMS', 'SMS')], max_length=20),
        ),
        migrations.CreateModel(
            name='IncomingMessage',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('phone_from', models.CharField(max_length=30)),
                ('text', models.TextField()),
                ('received_at', models.DateTimeField(auto_now_add=True)),
                ('raw_payload', models.JSONField()),
                ('parsed_action', models.CharField(choices=[('NONE', 'None'), ('CONFIRMED', 'Confirmed'), ('DELAYED', 'Delayed'), ('CANCELED', 'Canceled')], default='NONE', max_length=20)),
                ('matched_notification', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='incoming_messages', to='notifications.notificationqueue')),
            ],
        ),
    ]

----- END FILE: apps/notifications/migrations/0002_notificationqueue_action_taken_and_more.py -----

----- BEGIN FILE: apps/notifications/models.py -----
from django.conf import settings
from django.db import models

from utils.constants import (
    CHANNEL_CHOICES,
    NOTIFICATION_ACTION_CHOICES,
    NOTIFICATION_STATUS_CHOICES,
    ACTION_NONE,
    NOTIF_PENDING,
)


# Bloco: Fila de notificacoes
class NotificationQueue(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name="notifications")
    channel = models.CharField(max_length=20, choices=CHANNEL_CHOICES)
    title = models.CharField(max_length=200)
    message = models.TextField()
    scheduled_for = models.DateTimeField()
    status = models.CharField(max_length=20, choices=NOTIFICATION_STATUS_CHOICES, default=NOTIF_PENDING)
    action_taken = models.CharField(max_length=20, choices=NOTIFICATION_ACTION_CHOICES, default=ACTION_NONE)
    provider = models.CharField(max_length=50, blank=True)
    provider_message_id = models.CharField(max_length=200, blank=True)
    last_error = models.TextField(blank=True)
    attempts = models.PositiveIntegerField(default=0)
    to_phone = models.CharField(max_length=30, blank=True)
    sent_at = models.DateTimeField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.user.email} - {self.channel}"


# Bloco: Mensagens recebidas do WhatsApp
class IncomingMessage(models.Model):
    phone_from = models.CharField(max_length=30)
    text = models.TextField()
    received_at = models.DateTimeField(auto_now_add=True)
    raw_payload = models.JSONField()
    parsed_action = models.CharField(max_length=20, choices=NOTIFICATION_ACTION_CHOICES, default=ACTION_NONE)
    matched_notification = models.ForeignKey(
        NotificationQueue, on_delete=models.SET_NULL, null=True, blank=True, related_name="incoming_messages"
    )

    def __str__(self):
        return f"{self.phone_from} - {self.received_at:%Y-%m-%d %H:%M}"

----- END FILE: apps/notifications/models.py -----

----- BEGIN FILE: apps/notifications/serializers.py -----
from rest_framework import serializers

from notifications.models import NotificationQueue


class NotificationQueueSerializer(serializers.ModelSerializer):
    class Meta:
        model = NotificationQueue
        fields = (
            "id",
            "channel",
            "title",
            "message",
            "scheduled_for",
            "status",
            "created_at",
        )
        read_only_fields = ("id", "created_at")

----- END FILE: apps/notifications/serializers.py -----

----- BEGIN FILE: apps/notifications/services/reminder_queue.py -----
from datetime import datetime, time, timedelta

from django.utils import timezone

from accounts.models import UserProfile
from agenda.models import CalendarEvent, ReminderRule
from notifications.models import NotificationQueue
from planner.models import Task
from utils.constants import (
    CHANNEL_EMAIL,
    CHANNEL_SMS,
    CHANNEL_WHATSAPP,
    NOTIF_PENDING,
    REMINDER_TARGET_EVENT,
    REMINDER_TARGET_TASK,
)


# Bloco: Preferencias do usuario
def _get_user_preferences(user):
    try:
        profile = user.profile
    except UserProfile.DoesNotExist:
        profile = None

    return {
        "allow_email": getattr(profile, "allow_email", True),
        "allow_whatsapp": getattr(profile, "allow_whatsapp", True),
        "allow_sms": getattr(profile, "allow_sms", False),
        "phone": getattr(profile, "phone", "") or getattr(user, "phone_number", ""),
    }


# Bloco: Filtro de canais permitidos
def _filter_channels(channels, prefs):
    allowed = []
    for channel in channels:
        if channel == CHANNEL_EMAIL and prefs["allow_email"]:
            allowed.append(channel)
        if channel == CHANNEL_WHATSAPP and prefs["allow_whatsapp"]:
            allowed.append(channel)
        if channel == CHANNEL_SMS and prefs["allow_sms"]:
            allowed.append(channel)
    return allowed


# Bloco: Criacao de notificacao
def _queue_notification(user, channel, title, message, scheduled_for, phone=""):
    exists = NotificationQueue.objects.filter(
        user=user,
        channel=channel,
        title=title,
        scheduled_for=scheduled_for,
    ).exists()
    if exists:
        return False

    NotificationQueue.objects.create(
        user=user,
        channel=channel,
        title=title,
        message=message,
        scheduled_for=scheduled_for,
        status=NOTIF_PENDING,
        to_phone=phone or "",
    )
    return True


# Bloco: Lembretes para evento
def create_notifications_for_event(user, event: CalendarEvent) -> int:
    now = timezone.now()
    created = 0
    prefs = _get_user_preferences(user)
    rules = ReminderRule.objects.filter(user=user, is_active=True, target_type=REMINDER_TARGET_EVENT)
    for rule in rules:
        channels = rule.channels or [CHANNEL_EMAIL]
        allowed_channels = _filter_channels(channels, prefs)
        scheduled_for = event.start_at - timedelta(minutes=rule.remind_before_minutes)
        if scheduled_for < now:
            scheduled_for = now
        for channel in allowed_channels:
            title = f"Lembrete: {event.title}"
            message = f"Evento {event.title} em {event.start_at}."
            phone = prefs["phone"] if channel in {CHANNEL_WHATSAPP, CHANNEL_SMS} else ""
            if _queue_notification(user, channel, title, message, scheduled_for, phone):
                created += 1
    return created


# Bloco: Lembretes para tarefa
def create_notifications_for_task(user, task: Task) -> int:
    now = timezone.now()
    created = 0
    prefs = _get_user_preferences(user)
    rules = ReminderRule.objects.filter(user=user, is_active=True, target_type=REMINDER_TARGET_TASK)
    for rule in rules:
        channels = rule.channels or [CHANNEL_EMAIL]
        allowed_channels = _filter_channels(channels, prefs)
        due_datetime = datetime.combine(task.due_date, time(9, 0), tzinfo=timezone.get_current_timezone())
        scheduled_for = due_datetime - timedelta(minutes=rule.remind_before_minutes)
        if scheduled_for < now:
            scheduled_for = now
        for channel in allowed_channels:
            title = f"Lembrete: {task.title}"
            message = f"Tarefa {task.title} vence em {task.due_date}."
            phone = prefs["phone"] if channel in {CHANNEL_WHATSAPP, CHANNEL_SMS} else ""
            if _queue_notification(user, channel, title, message, scheduled_for, phone):
                created += 1
    return created


# Bloco: Lembretes para usuario (geracao completa)
def create_notifications_for_user(user) -> int:
    created = 0
    now = timezone.now()
    events = CalendarEvent.objects.filter(user=user, start_at__gte=now)
    for event in events:
        created += create_notifications_for_event(user, event)

    tasks = Task.objects.filter(user=user, due_date__gte=timezone.localdate())
    for task in tasks:
        created += create_notifications_for_task(user, task)

    return created

----- END FILE: apps/notifications/services/reminder_queue.py -----

----- BEGIN FILE: apps/notifications/services/whatsapp_cloud.py -----
import json
import re
import urllib.request
from typing import Dict

from django.conf import settings


# Bloco: Normalizacao de telefone
def normalize_phone(raw_phone: str) -> str:
    if not raw_phone:
        return ""
    digits = re.sub(r"\D", "", raw_phone)
    if digits.startswith("55"):
        return digits
    return f"55{digits}"


# Bloco: Envio de mensagem via WhatsApp Cloud API
def send_whatsapp_text(to_phone: str, body: str) -> Dict:
    token = getattr(settings, "WHATSAPP_CLOUD_TOKEN", "")
    phone_number_id = getattr(settings, "WHATSAPP_PHONE_NUMBER_ID", "")
    if not token or not phone_number_id:
        raise RuntimeError("Credenciais do WhatsApp Cloud nao configuradas.")

    normalized = normalize_phone(to_phone)
    if not normalized:
        raise RuntimeError("Telefone invalido para envio de WhatsApp.")

    url = f"https://graph.facebook.com/v19.0/{phone_number_id}/messages"
    payload = {
        "messaging_product": "whatsapp",
        "to": normalized,
        "type": "text",
        "text": {"body": body},
    }
    data = json.dumps(payload).encode("utf-8")
    request = urllib.request.Request(
        url,
        data=data,
        headers={
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
        },
        method="POST",
    )
    try:
        with urllib.request.urlopen(request, timeout=10) as response:
            raw = response.read().decode("utf-8")
            return json.loads(raw)
    except Exception as exc:  # pragma: no cover
        raise RuntimeError(f"Erro ao enviar WhatsApp: {exc}") from exc

----- END FILE: apps/notifications/services/whatsapp_cloud.py -----

----- BEGIN FILE: apps/notifications/services/whatsapp_service.py -----
import logging
import re
from typing import Dict, Optional

import requests
from django.conf import settings

logger = logging.getLogger(__name__)


# Bloco: Normalizacao de telefone
def normalize_phone(raw_phone: str) -> str:
    if not raw_phone:
        return ""
    digits = re.sub(r"\D", "", raw_phone)
    if digits.startswith("55"):
        return digits
    return f"55{digits}"


# Bloco: Envio de mensagem WhatsApp (retorna resposta)
def send_whatsapp_message_raw(phone_number: str, message: str) -> Optional[Dict]:
    token = getattr(settings, "WHATSAPP_CLOUD_TOKEN", "")
    phone_number_id = getattr(settings, "WHATSAPP_PHONE_NUMBER_ID", "")
    if not token or not phone_number_id:
        logger.error("Credenciais do WhatsApp Cloud nao configuradas.")
        return None

    normalized = normalize_phone(phone_number)
    if not normalized:
        logger.error("Telefone invalido para envio de WhatsApp.")
        return None

    url = f"https://graph.facebook.com/v22.0/{phone_number_id}/messages"
    payload = {
        "messaging_product": "whatsapp",
        "to": normalized,
        "type": "text",
        "text": {"body": message},
    }
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json",
    }

    try:
        response = requests.post(url, json=payload, headers=headers, timeout=10)
        if response.status_code >= 400:
            logger.error("Erro WhatsApp Cloud %s: %s", response.status_code, response.text)
            return None
        return response.json()
    except requests.RequestException as exc:
        logger.exception("Erro ao enviar WhatsApp: %s", exc)
        return None


# Bloco: Envio de mensagem WhatsApp (retorna sucesso)
def send_whatsapp_message(phone_number: str, message: str) -> bool:
    return send_whatsapp_message_raw(phone_number, message) is not None

----- END FILE: apps/notifications/services/whatsapp_service.py -----

----- BEGIN FILE: apps/notifications/urls.py -----
from django.urls import path

from . import views

urlpatterns = [
    path("test-email/", views.TestEmailView.as_view(), name="notifications-test-email"),
    path("pending/", views.PendingNotificationsView.as_view(), name="notifications-pending"),
    path("whatsapp/webhook/", views.whatsapp_webhook_view, name="notifications-whatsapp-webhook"),
]

----- END FILE: apps/notifications/urls.py -----

----- BEGIN FILE: apps/notifications/views.py -----
import json
import re
from datetime import timedelta

from django.conf import settings
from django.core.mail import send_mail
from django.http import HttpResponse, HttpResponseForbidden, JsonResponse
from django.utils import timezone
from django.views.decorators.csrf import csrf_exempt
from rest_framework import permissions, status
from rest_framework.response import Response
from rest_framework.views import APIView

from notifications.models import IncomingMessage, NotificationQueue
from notifications.serializers import NotificationQueueSerializer
from notifications.services.whatsapp_service import send_whatsapp_message_raw
from utils.constants import (
    ACTION_CANCELED,
    ACTION_CONFIRMED,
    ACTION_DELAYED,
    ACTION_NONE,
    CHANNEL_EMAIL,
    CHANNEL_WHATSAPP,
    NOTIF_PENDING,
    NOTIF_SENT,
)
from utils.features import has_feature
from utils.constants import FEATURE_EMAIL_NOTIFICATIONS


class TestEmailView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def post(self, request):
        if not has_feature(request.user, FEATURE_EMAIL_NOTIFICATIONS):
            return Response({"detail": "Plano atual nao permite email."}, status=status.HTTP_403_FORBIDDEN)
        subject = "Campus Calm - Teste de Email"
        message = "Este e um email de teste do Campus Calm."
        send_mail(subject, message, None, [request.user.email])
        return Response({"detail": "Email enviado para console."})


class PendingNotificationsView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        now = timezone.now()
        pending = NotificationQueue.objects.filter(
            user=request.user, status=NOTIF_PENDING, scheduled_for__lte=now
        ).order_by("scheduled_for")
        return Response(NotificationQueueSerializer(pending, many=True).data)


# Bloco: Webhook WhatsApp Cloud
@csrf_exempt
def whatsapp_webhook_view(request):
    if request.method == "GET":
        verify_token = request.GET.get("hub.verify_token", "")
        challenge = request.GET.get("hub.challenge", "")
        if verify_token and verify_token == getattr(settings, "WHATSAPP_VERIFY_TOKEN", ""):
            return HttpResponse(challenge, status=200)
        return HttpResponseForbidden("Token invalido.")

    if request.method != "POST":
        return JsonResponse({"detail": "Metodo nao permitido."}, status=405)

    try:
        payload = json.loads(request.body.decode("utf-8") or "{}")
    except json.JSONDecodeError:
        payload = {}

    phone_from, text_body = _extract_whatsapp_message(payload)
    parsed_action = _parse_action(text_body)
    matched_notification = _match_notification(phone_from, text_body)

    incoming = IncomingMessage.objects.create(
        phone_from=phone_from or "",
        text=text_body or "",
        raw_payload=payload,
        parsed_action=parsed_action,
        matched_notification=matched_notification,
    )

    if matched_notification and parsed_action != ACTION_NONE:
        _apply_action(matched_notification, parsed_action)

    return JsonResponse({"detail": "ok", "incoming_id": incoming.id})


# Bloco: Extracao de mensagem do payload
def _extract_whatsapp_message(payload):
    try:
        entry = payload.get("entry", [])[0]
        change = entry.get("changes", [])[0]
        value = change.get("value", {})
        message = value.get("messages", [])[0]
        phone_from = message.get("from", "")
        text_body = message.get("text", {}).get("body", "")
        return phone_from, text_body
    except (IndexError, AttributeError):
        return "", ""


# Bloco: Interpretacao da acao
def _parse_action(text_body: str):
    if not text_body:
        return ACTION_NONE
    text = text_body.strip()
    if text.startswith("1"):
        return ACTION_CONFIRMED
    if text.startswith("2"):
        return ACTION_DELAYED
    if text.startswith("3"):
        return ACTION_CANCELED
    return ACTION_NONE


# Bloco: Matching da notificacao
def _match_notification(phone_from: str, text_body: str):
    if not phone_from and not text_body:
        return None

    match = re.search(r"N(\\d+)", text_body.upper())
    if match:
        notification_id = int(match.group(1))
        notification = NotificationQueue.objects.filter(id=notification_id).first()
        if notification and (not notification.to_phone or notification.to_phone == phone_from):
            return notification
        return None

    if phone_from:
        since = timezone.now() - timedelta(hours=24)
        return (
            NotificationQueue.objects.filter(
                channel=CHANNEL_WHATSAPP,
                to_phone=phone_from,
                status=NOTIF_SENT,
                action_taken=ACTION_NONE,
                created_at__gte=since,
            )
            .order_by("-created_at")
            .first()
        )

    return None


# Bloco: Aplicacao da acao e resposta
def _apply_action(notification: NotificationQueue, action: str):
    notification.action_taken = action
    notification.save(update_fields=["action_taken"])

    if action == ACTION_CONFIRMED:
        _reply_whatsapp(notification.to_phone, "Confirmado ")
        return

    if action == ACTION_DELAYED:
        delayed_for = timezone.now() + timedelta(minutes=10)
        NotificationQueue.objects.create(
            user=notification.user,
            channel=notification.channel,
            title=notification.title,
            message=notification.message,
            scheduled_for=delayed_for,
            status=NOTIF_PENDING,
            to_phone=notification.to_phone,
        )
        _reply_whatsapp(notification.to_phone, "Adiado por 10 minutos ")
        return

    if action == ACTION_CANCELED:
        _reply_whatsapp(notification.to_phone, "Cancelado ")


# Bloco: Envio de resposta via WhatsApp
def _reply_whatsapp(phone: str, body: str):
    if not phone:
        return
    try:
        send_whatsapp_message_raw(phone, body)
    except Exception:
        return

----- END FILE: apps/notifications/views.py -----

----- BEGIN FILE: apps/onboarding/admin.py -----
from django.contrib import admin

from onboarding.models import UserSetupProgress


@admin.register(UserSetupProgress)
class UserSetupProgressAdmin(admin.ModelAdmin):
    list_display = ("user", "has_profile", "has_active_semester", "has_at_least_one_course", "has_at_least_one_assessment", "has_reminder_rule")

----- END FILE: apps/onboarding/admin.py -----

----- BEGIN FILE: apps/onboarding/apps.py -----
from django.apps import AppConfig


class OnboardingConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'onboarding'

    def ready(self):
        from onboarding import signals  # noqa: F401

----- END FILE: apps/onboarding/apps.py -----

----- BEGIN FILE: apps/onboarding/migrations/0001_initial.py -----
# Generated by Django 4.2.11 on 2026-01-28 13:35

from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='UserSetupProgress',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('has_profile', models.BooleanField(default=False)),
                ('has_active_semester', models.BooleanField(default=False)),
                ('has_at_least_one_course', models.BooleanField(default=False)),
                ('has_at_least_one_assessment', models.BooleanField(default=False)),
                ('has_reminder_rule', models.BooleanField(default=False)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('user', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='setup_progress', to=settings.AUTH_USER_MODEL)),
            ],
        ),
    ]

----- END FILE: apps/onboarding/migrations/0001_initial.py -----

----- BEGIN FILE: apps/onboarding/models.py -----
from django.conf import settings
from django.db import models


class UserSetupProgress(models.Model):
    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name="setup_progress")
    has_profile = models.BooleanField(default=False)
    has_active_semester = models.BooleanField(default=False)
    has_at_least_one_course = models.BooleanField(default=False)
    has_at_least_one_assessment = models.BooleanField(default=False)
    has_reminder_rule = models.BooleanField(default=False)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.user.email

----- END FILE: apps/onboarding/models.py -----

----- BEGIN FILE: apps/onboarding/services.py -----
from semester.models import Assessment, Course, Semester
from agenda.models import ReminderRule
from onboarding.models import UserSetupProgress
from utils.constants import SEMESTER_ACTIVE


def refresh_user_progress(user):
    progress, _ = UserSetupProgress.objects.get_or_create(user=user)
    progress.has_profile = bool(user.name)
    progress.has_active_semester = Semester.objects.filter(user=user, status=SEMESTER_ACTIVE).exists()
    progress.has_at_least_one_course = Course.objects.filter(semester__user=user).exists()
    progress.has_at_least_one_assessment = Assessment.objects.filter(course__semester__user=user).exists()
    progress.has_reminder_rule = ReminderRule.objects.filter(user=user, is_active=True).exists()
    progress.save()
    return progress

----- END FILE: apps/onboarding/services.py -----

----- BEGIN FILE: apps/onboarding/signals.py -----
from django.db.models.signals import post_delete, post_save
from django.dispatch import receiver

from accounts.models import User
from agenda.models import ReminderRule
from onboarding.services import refresh_user_progress
from semester.models import Assessment, Course, Semester


@receiver(post_save, sender=User)
def user_saved(sender, instance, **kwargs):
    refresh_user_progress(instance)


@receiver(post_save, sender=Semester)
@receiver(post_delete, sender=Semester)
def semester_changed(sender, instance, **kwargs):
    refresh_user_progress(instance.user)


@receiver(post_save, sender=Course)
@receiver(post_delete, sender=Course)
def course_changed(sender, instance, **kwargs):
    refresh_user_progress(instance.semester.user)


@receiver(post_save, sender=Assessment)
@receiver(post_delete, sender=Assessment)
def assessment_changed(sender, instance, **kwargs):
    refresh_user_progress(instance.course.semester.user)


@receiver(post_save, sender=ReminderRule)
@receiver(post_delete, sender=ReminderRule)
def reminder_changed(sender, instance, **kwargs):
    refresh_user_progress(instance.user)

----- END FILE: apps/onboarding/signals.py -----

----- BEGIN FILE: apps/onboarding/urls.py -----
from django.urls import path

from onboarding.views import OnboardingStatusView

urlpatterns = [
    path("status/", OnboardingStatusView.as_view(), name="onboarding-status"),
]

----- END FILE: apps/onboarding/urls.py -----

----- BEGIN FILE: apps/onboarding/views.py -----
from rest_framework import permissions
from rest_framework.response import Response
from rest_framework.views import APIView

from onboarding.services import refresh_user_progress
from utils.gating import compute_status


class OnboardingStatusView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        progress = refresh_user_progress(request.user)
        current_step, missing_steps, required_actions = compute_status(progress)
        return Response(
            {
                "current_step": current_step,
                "missing_steps": missing_steps,
                "required_actions": required_actions,
            }
        )

----- END FILE: apps/onboarding/views.py -----

----- BEGIN FILE: apps/planner/admin.py -----
from django.contrib import admin

from planner.models import Task


@admin.register(Task)
class TaskAdmin(admin.ModelAdmin):
    list_display = ("title", "user", "due_date", "status")
    list_filter = ("status",)
    search_fields = ("title", "user__email")

----- END FILE: apps/planner/admin.py -----

----- BEGIN FILE: apps/planner/apps.py -----
from django.apps import AppConfig


class PlannerConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'planner'

----- END FILE: apps/planner/apps.py -----

----- BEGIN FILE: apps/planner/migrations/0001_initial.py -----
# Generated by Django 4.2.11 on 2026-01-28 13:35

from django.conf import settings
import django.core.validators
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Task',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=200)),
                ('description', models.TextField(blank=True)),
                ('due_date', models.DateField()),
                ('stress_level', models.PositiveSmallIntegerField(validators=[django.core.validators.MinValueValidator(1), django.core.validators.MaxValueValidator(5)])),
                ('status', models.CharField(choices=[('TODO', 'Todo'), ('DOING', 'Doing'), ('DONE', 'Done')], default='TODO', max_length=10)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='tasks', to=settings.AUTH_USER_MODEL)),
            ],
        ),
    ]

----- END FILE: apps/planner/migrations/0001_initial.py -----

----- BEGIN FILE: apps/planner/models.py -----
from django.conf import settings
from django.core.validators import MaxValueValidator, MinValueValidator
from django.db import models

from utils.constants import TASK_STATUS_CHOICES, TASK_TODO


class Task(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name="tasks")
    title = models.CharField(max_length=200)
    description = models.TextField(blank=True)
    due_date = models.DateField()
    stress_level = models.PositiveSmallIntegerField(validators=[MinValueValidator(1), MaxValueValidator(5)])
    status = models.CharField(max_length=10, choices=TASK_STATUS_CHOICES, default=TASK_TODO)
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.title

----- END FILE: apps/planner/models.py -----

----- BEGIN FILE: apps/planner/serializers.py -----
from rest_framework import serializers

from planner.models import Task


class TaskSerializer(serializers.ModelSerializer):
    class Meta:
        model = Task
        fields = (
            "id",
            "title",
            "description",
            "due_date",
            "stress_level",
            "status",
            "created_at",
        )
        read_only_fields = ("id", "created_at")

----- END FILE: apps/planner/serializers.py -----

----- BEGIN FILE: apps/planner/urls.py -----
from rest_framework.routers import DefaultRouter

from planner.views import TaskViewSet

router = DefaultRouter()
router.register(r"tasks", TaskViewSet, basename="tasks")

urlpatterns = router.urls

----- END FILE: apps/planner/urls.py -----

----- BEGIN FILE: apps/planner/views.py -----
from rest_framework import permissions, viewsets

from planner.models import Task
from planner.serializers import TaskSerializer
from utils.constants import FEATURE_PLANNER_BASIC
from utils.features import require_feature


class TaskViewSet(viewsets.ModelViewSet):
    serializer_class = TaskSerializer
    permission_classes = [permissions.IsAuthenticated]

    def initial(self, request, *args, **kwargs):
        require_feature(request.user, FEATURE_PLANNER_BASIC)
        return super().initial(request, *args, **kwargs)

    def get_queryset(self):
        return Task.objects.filter(user=self.request.user).order_by("-created_at")

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)

----- END FILE: apps/planner/views.py -----

----- BEGIN FILE: apps/pomodoro/admin.py -----
from django.contrib import admin

from pomodoro.models import PomodoroSession


@admin.register(PomodoroSession)
class PomodoroSessionAdmin(admin.ModelAdmin):
    list_display = ("user", "status", "started_at", "ended_at")
    list_filter = ("status",)

----- END FILE: apps/pomodoro/admin.py -----

----- BEGIN FILE: apps/pomodoro/apps.py -----
from django.apps import AppConfig


class PomodoroConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'pomodoro'

----- END FILE: apps/pomodoro/apps.py -----

----- BEGIN FILE: apps/pomodoro/migrations/0001_initial.py -----
# Generated by Django 4.2.11 on 2026-01-28 13:35

from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion
import django.utils.timezone


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='PomodoroSession',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('focus_minutes', models.PositiveIntegerField(default=25)),
                ('break_minutes', models.PositiveIntegerField(default=5)),
                ('started_at', models.DateTimeField(default=django.utils.timezone.now)),
                ('ended_at', models.DateTimeField(blank=True, null=True)),
                ('status', models.CharField(choices=[('COMPLETED', 'Completed'), ('STOPPED', 'Stopped')], default='STOPPED', max_length=20)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='pomodoro_sessions', to=settings.AUTH_USER_MODEL)),
            ],
        ),
    ]

----- END FILE: apps/pomodoro/migrations/0001_initial.py -----

----- BEGIN FILE: apps/pomodoro/models.py -----
from django.conf import settings
from django.db import models
from django.utils import timezone

from utils.constants import POMODORO_STATUS_CHOICES, POMODORO_STOPPED


class PomodoroSession(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name="pomodoro_sessions")
    focus_minutes = models.PositiveIntegerField(default=25)
    break_minutes = models.PositiveIntegerField(default=5)
    started_at = models.DateTimeField(default=timezone.now)
    ended_at = models.DateTimeField(null=True, blank=True)
    status = models.CharField(max_length=20, choices=POMODORO_STATUS_CHOICES, default=POMODORO_STOPPED)

    def __str__(self):
        return f"{self.user.email} - {self.status}"

----- END FILE: apps/pomodoro/models.py -----

----- BEGIN FILE: apps/pomodoro/serializers.py -----
from rest_framework import serializers

from pomodoro.models import PomodoroSession


class PomodoroSessionSerializer(serializers.ModelSerializer):
    class Meta:
        model = PomodoroSession
        fields = (
            "id",
            "focus_minutes",
            "break_minutes",
            "started_at",
            "ended_at",
            "status",
        )
        read_only_fields = ("id", "started_at", "ended_at", "status")

----- END FILE: apps/pomodoro/serializers.py -----

----- BEGIN FILE: apps/pomodoro/urls.py -----
from django.urls import path

from pomodoro.views import PomodoroStartView, PomodoroStopView, PomodoroWeeklySummaryView

urlpatterns = [
    path("start/", PomodoroStartView.as_view(), name="pomodoro-start"),
    path("stop/<int:pk>/", PomodoroStopView.as_view(), name="pomodoro-stop"),
    path("summary/weekly/", PomodoroWeeklySummaryView.as_view(), name="pomodoro-summary-weekly"),
]

----- END FILE: apps/pomodoro/urls.py -----

----- BEGIN FILE: apps/pomodoro/views.py -----
from datetime import timedelta

from django.utils import timezone
from rest_framework import permissions, status
from rest_framework.response import Response
from rest_framework.views import APIView

from pomodoro.models import PomodoroSession
from pomodoro.serializers import PomodoroSessionSerializer
from utils.constants import FEATURE_POMODORO_BASIC, POMODORO_COMPLETED, POMODORO_STOPPED
from utils.features import require_feature


class PomodoroStartView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def post(self, request):
        require_feature(request.user, FEATURE_POMODORO_BASIC)
        focus_minutes = int(request.data.get("focus_minutes", 25))
        break_minutes = int(request.data.get("break_minutes", 5))
        session = PomodoroSession.objects.create(
            user=request.user,
            focus_minutes=focus_minutes,
            break_minutes=break_minutes,
        )
        return Response(PomodoroSessionSerializer(session).data, status=status.HTTP_201_CREATED)


class PomodoroStopView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def post(self, request, pk):
        require_feature(request.user, FEATURE_POMODORO_BASIC)
        session = PomodoroSession.objects.get(pk=pk, user=request.user)
        completed_value = request.data.get("completed", False)
        completed = str(completed_value).lower() in {"1", "true", "yes", "on"}
        session.ended_at = timezone.now()
        session.status = POMODORO_COMPLETED if completed else POMODORO_STOPPED
        session.save()
        return Response(PomodoroSessionSerializer(session).data)


class PomodoroWeeklySummaryView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request):
        require_feature(request.user, FEATURE_POMODORO_BASIC)
        week_ago = timezone.now() - timedelta(days=7)
        sessions = PomodoroSession.objects.filter(user=request.user, started_at__gte=week_ago)
        total_sessions = sessions.count()
        total_focus_minutes = sum(session.focus_minutes for session in sessions)
        return Response(
            {
                "total_sessions": total_sessions,
                "total_focus_minutes": total_focus_minutes,
            }
        )

----- END FILE: apps/pomodoro/views.py -----

----- BEGIN FILE: apps/semester/admin.py -----
from django.contrib import admin

from semester.models import Assessment, Course, Semester, SemesterCheckin


@admin.register(Semester)
class SemesterAdmin(admin.ModelAdmin):
    list_display = ("name", "user", "status", "start_date", "end_date")
    list_filter = ("status",)


@admin.register(Course)
class CourseAdmin(admin.ModelAdmin):
    list_display = ("title", "semester", "status", "passing_grade", "final_grade")
    list_filter = ("status",)


@admin.register(Assessment)
class AssessmentAdmin(admin.ModelAdmin):
    list_display = ("title", "course", "score", "max_score", "weight")


@admin.register(SemesterCheckin)
class SemesterCheckinAdmin(admin.ModelAdmin):
    list_display = ("semester", "overall_stress", "created_at")

----- END FILE: apps/semester/admin.py -----

----- BEGIN FILE: apps/semester/apps.py -----
from django.apps import AppConfig


class SemesterConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'semester'

----- END FILE: apps/semester/apps.py -----

----- BEGIN FILE: apps/semester/migrations/0001_initial.py -----
# Generated by Django 4.2.11 on 2026-01-28 13:35

from decimal import Decimal
from django.conf import settings
import django.core.validators
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Semester',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=50)),
                ('start_date', models.DateField()),
                ('end_date', models.DateField()),
                ('status', models.CharField(choices=[('ACTIVE', 'Active'), ('FINISHED', 'Finished')], default='ACTIVE', max_length=20)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='semesters', to=settings.AUTH_USER_MODEL)),
            ],
        ),
        migrations.CreateModel(
            name='SemesterCheckin',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('overall_stress', models.PositiveSmallIntegerField(validators=[django.core.validators.MinValueValidator(1), django.core.validators.MaxValueValidator(5)])),
                ('comment', models.TextField(blank=True)),
                ('semester', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='checkins', to='semester.semester')),
            ],
        ),
        migrations.CreateModel(
            name='Course',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=200)),
                ('teacher', models.CharField(blank=True, max_length=200)),
                ('credits', models.PositiveIntegerField(blank=True, null=True)),
                ('passing_grade', models.DecimalField(decimal_places=2, default=Decimal('7.0'), max_digits=4)),
                ('status', models.CharField(choices=[('IN_PROGRESS', 'In progress'), ('PASSED', 'Passed'), ('FAILED', 'Failed')], default='IN_PROGRESS', max_length=20)),
                ('final_grade', models.DecimalField(blank=True, decimal_places=2, max_digits=5, null=True)),
                ('notes', models.TextField(blank=True)),
                ('semester', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='courses', to='semester.semester')),
            ],
        ),
        migrations.CreateModel(
            name='Assessment',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=200)),
                ('score', models.DecimalField(decimal_places=2, max_digits=5, validators=[django.core.validators.MinValueValidator(0)])),
                ('max_score', models.DecimalField(decimal_places=2, default=Decimal('10.0'), max_digits=5)),
                ('weight', models.DecimalField(decimal_places=2, default=Decimal('1.0'), max_digits=5, validators=[django.core.validators.MinValueValidator(0)])),
                ('date', models.DateField(blank=True, null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('course', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='assessments', to='semester.course')),
            ],
        ),
    ]

----- END FILE: apps/semester/migrations/0001_initial.py -----

----- BEGIN FILE: apps/semester/models.py -----
from decimal import Decimal

from django.conf import settings
from django.core.validators import MaxValueValidator, MinValueValidator
from django.db import models

from utils.constants import COURSE_STATUS_CHOICES, COURSE_IN_PROGRESS, SEMESTER_STATUS_CHOICES, SEMESTER_ACTIVE


class Semester(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name="semesters")
    name = models.CharField(max_length=50)
    start_date = models.DateField()
    end_date = models.DateField()
    status = models.CharField(max_length=20, choices=SEMESTER_STATUS_CHOICES, default=SEMESTER_ACTIVE)

    def __str__(self):
        return self.name


class Course(models.Model):
    semester = models.ForeignKey(Semester, on_delete=models.CASCADE, related_name="courses")
    title = models.CharField(max_length=200)
    teacher = models.CharField(max_length=200, blank=True)
    credits = models.PositiveIntegerField(null=True, blank=True)
    passing_grade = models.DecimalField(max_digits=4, decimal_places=2, default=Decimal("7.0"))
    status = models.CharField(max_length=20, choices=COURSE_STATUS_CHOICES, default=COURSE_IN_PROGRESS)
    final_grade = models.DecimalField(max_digits=5, decimal_places=2, null=True, blank=True)
    notes = models.TextField(blank=True)

    def __str__(self):
        return self.title


class Assessment(models.Model):
    course = models.ForeignKey(Course, on_delete=models.CASCADE, related_name="assessments")
    title = models.CharField(max_length=200)
    score = models.DecimalField(max_digits=5, decimal_places=2, validators=[MinValueValidator(0)])
    max_score = models.DecimalField(max_digits=5, decimal_places=2, default=Decimal("10.0"))
    weight = models.DecimalField(max_digits=5, decimal_places=2, default=Decimal("1.0"), validators=[MinValueValidator(0)])
    date = models.DateField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.title


class SemesterCheckin(models.Model):
    semester = models.ForeignKey(Semester, on_delete=models.CASCADE, related_name="checkins")
    created_at = models.DateTimeField(auto_now_add=True)
    overall_stress = models.PositiveSmallIntegerField(validators=[MinValueValidator(1), MaxValueValidator(5)])
    comment = models.TextField(blank=True)

    def __str__(self):
        return f"{self.semester.name} checkin"

----- END FILE: apps/semester/models.py -----

----- BEGIN FILE: apps/semester/serializers.py -----
from decimal import Decimal

from rest_framework import serializers

from semester.models import Assessment, Course, Semester, SemesterCheckin
from utils.academic_progress import (
    calculate_course_average,
    calculate_needed_to_pass,
    calculate_progress_percent,
)


class SemesterSerializer(serializers.ModelSerializer):
    class Meta:
        model = Semester
        fields = ("id", "name", "start_date", "end_date", "status")
        read_only_fields = ("id",)


class CourseSerializer(serializers.ModelSerializer):
    current_average = serializers.SerializerMethodField()
    progress_percent = serializers.SerializerMethodField()
    needed_to_pass = serializers.SerializerMethodField()

    class Meta:
        model = Course
        fields = (
            "id",
            "semester",
            "title",
            "teacher",
            "credits",
            "passing_grade",
            "status",
            "final_grade",
            "notes",
            "current_average",
            "progress_percent",
            "needed_to_pass",
        )
        read_only_fields = ("id", "status", "final_grade", "current_average", "progress_percent", "needed_to_pass")

    def get_current_average(self, obj):
        return calculate_course_average(obj)

    def get_progress_percent(self, obj):
        return calculate_progress_percent(obj)

    def get_needed_to_pass(self, obj):
        return calculate_needed_to_pass(obj)


class AssessmentSerializer(serializers.ModelSerializer):
    class Meta:
        model = Assessment
        fields = ("id", "course", "title", "score", "max_score", "weight", "date", "created_at")
        read_only_fields = ("id", "created_at")

    def validate(self, attrs):
        score = attrs.get("score")
        max_score = attrs.get("max_score")
        weight = attrs.get("weight")
        if score is not None and max_score is not None and score > max_score:
            raise serializers.ValidationError("score deve ser <= max_score")
        if weight is not None and weight < 0:
            raise serializers.ValidationError("weight deve ser >= 0")
        return attrs


class SemesterCheckinSerializer(serializers.ModelSerializer):
    class Meta:
        model = SemesterCheckin
        fields = ("id", "semester", "created_at", "overall_stress", "comment")
        read_only_fields = ("id", "created_at")

----- END FILE: apps/semester/serializers.py -----

----- BEGIN FILE: apps/semester/tests.py -----
from datetime import date
from decimal import Decimal

from django.contrib.auth import get_user_model
from rest_framework.test import APITestCase
from rest_framework_simplejwt.tokens import RefreshToken

from coach_ai.models import CoachLog
from semester.models import Assessment, Course, Semester
from utils.constants import COACH_REPROVACAO, COACH_SEMESTRE_CONCLUIDO, COURSE_FAILED, COURSE_PASSED

User = get_user_model()


class SemesterProgressTests(APITestCase):
    def setUp(self):
        self.user = User.objects.create_user(email="semester@example.com", name="Semestre", password="pass12345")
        refresh = RefreshToken.for_user(self.user)
        self.client.credentials(HTTP_AUTHORIZATION=f"Bearer {refresh.access_token}")
        self.semester = Semester.objects.create(
            user=self.user,
            name="2026.1",
            start_date=date.today(),
            end_date=date.today(),
        )
        self.course = Course.objects.create(semester=self.semester, title="Matematica")

    def test_course_progress_requires_assessment(self):
        response = self.client.get(f"/api/semester/courses/{self.course.id}/progress/")
        self.assertEqual(response.status_code, 403)
        self.assertIn("detail", response.data)

    def test_finish_semester_passed(self):
        Assessment.objects.create(course=self.course, title="Prova 1", score=Decimal("9"), max_score=Decimal("10"))
        response = self.client.post(f"/api/semester/finish/{self.semester.id}/")
        self.assertEqual(response.status_code, 200)
        self.course.refresh_from_db()
        self.assertEqual(self.course.status, COURSE_PASSED)
        self.assertTrue(CoachLog.objects.filter(user=self.user, trigger_type=COACH_SEMESTRE_CONCLUIDO).exists())

    def test_finish_semester_failed(self):
        failing_course = Course.objects.create(semester=self.semester, title="Fisica", passing_grade=Decimal("7"))
        Assessment.objects.create(course=failing_course, title="Prova 1", score=Decimal("3"), max_score=Decimal("10"))
        response = self.client.post(f"/api/semester/finish/{self.semester.id}/")
        self.assertEqual(response.status_code, 200)
        failing_course.refresh_from_db()
        self.assertEqual(failing_course.status, COURSE_FAILED)
        self.assertTrue(CoachLog.objects.filter(user=self.user, trigger_type=COACH_REPROVACAO).exists())

----- END FILE: apps/semester/tests.py -----

----- BEGIN FILE: apps/semester/urls.py -----
from django.urls import path
from rest_framework.routers import DefaultRouter

from semester.views import AssessmentViewSet, CourseProgressView, CourseViewSet, FinishSemesterView, SemesterViewSet

router = DefaultRouter()
router.register(r"semesters", SemesterViewSet, basename="semesters")
router.register(r"courses", CourseViewSet, basename="courses")
router.register(r"assessments", AssessmentViewSet, basename="assessments")

urlpatterns = router.urls + [
    path("courses/<int:pk>/progress/", CourseProgressView.as_view(), name="course-progress"),
    path("finish/<int:semester_id>/", FinishSemesterView.as_view(), name="semester-finish"),
]

----- END FILE: apps/semester/urls.py -----

----- BEGIN FILE: apps/semester/views.py -----
from datetime import timedelta

from django.shortcuts import get_object_or_404
from django.utils import timezone
from rest_framework import permissions, status, viewsets
from rest_framework.exceptions import PermissionDenied
from rest_framework.response import Response
from rest_framework.views import APIView

from coach_ai.models import CoachLog
from semester.models import Assessment, Course, Semester
from semester.serializers import AssessmentSerializer, CourseSerializer, SemesterSerializer
from utils.academic_progress import (
    calculate_course_average,
    calculate_needed_to_pass,
    calculate_progress_percent,
    update_course_status,
)
from utils.constants import (
    CHANNEL_EMAIL,
    CHANNEL_IN_APP,
    COACH_REPROVACAO,
    COACH_SEMESTRE_CONCLUIDO,
    COURSE_FAILED,
    SEMESTER_FINISHED,
)
from utils.gating import gate_course_progress, gate_finish_semester
from utils.messages import (
    MESSAGE_ACHIEVEMENT,
    MESSAGE_CARE,
    MESSAGE_INCENTIVE,
    MESSAGE_WARNING,
    send_message,
)


class SemesterViewSet(viewsets.ModelViewSet):
    serializer_class = SemesterSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        return Semester.objects.filter(user=self.request.user).order_by("-start_date")

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)


class CourseViewSet(viewsets.ModelViewSet):
    serializer_class = CourseSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        return Course.objects.filter(semester__user=self.request.user).order_by("title")

    def perform_create(self, serializer):
        semester = serializer.validated_data["semester"]
        if semester.user != self.request.user:
            raise PermissionDenied("Semestre nao pertence ao usuario")
        serializer.save()


class AssessmentViewSet(viewsets.ModelViewSet):
    serializer_class = AssessmentSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        return Assessment.objects.filter(course__semester__user=self.request.user).order_by("-created_at")

    def perform_create(self, serializer):
        course = serializer.validated_data["course"]
        if course.semester.user != self.request.user:
            raise PermissionDenied("Curso nao pertence ao usuario")
        previous_progress = calculate_progress_percent(course)
        serializer.save()
        course.refresh_from_db()
        new_progress = calculate_progress_percent(course)
        update_course_status(course, semester_status=course.semester.status)
        course.final_grade = calculate_course_average(course)
        course.save(update_fields=["status", "final_grade"])

        if new_progress > previous_progress:
            send_message(
                self.request.user,
                MESSAGE_INCENTIVE,
                {
                    "event": "assessment_progress_up",
                    "course": course.title,
                    "progress": int(new_progress),
                },
                channels=[CHANNEL_IN_APP, CHANNEL_EMAIL],
            )
        elif new_progress < previous_progress:
            send_message(
                self.request.user,
                MESSAGE_CARE,
                {
                    "event": "assessment_progress_down",
                    "course": course.title,
                    "progress": int(new_progress),
                },
                channels=[CHANNEL_IN_APP, CHANNEL_EMAIL],
            )

        if new_progress >= 100 and previous_progress < 100:
            send_message(
                self.request.user,
                MESSAGE_ACHIEVEMENT,
                {
                    "event": "course_passed",
                    "course": course.title,
                    "progress": int(new_progress),
                },
                channels=[CHANNEL_IN_APP, CHANNEL_EMAIL],
            )

        week_ahead = timezone.localdate() + timedelta(days=7)
        upcoming = course.assessments.filter(date__gte=timezone.localdate(), date__lte=week_ahead).exists()
        if new_progress < 70 and upcoming:
            send_message(
                self.request.user,
                MESSAGE_WARNING,
                {
                    "event": "low_progress_upcoming",
                    "course": course.title,
                    "progress": int(new_progress),
                },
                channels=[CHANNEL_IN_APP, CHANNEL_EMAIL],
            )


class CourseProgressView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request, pk):
        course = get_object_or_404(Course, pk=pk, semester__user=request.user)
        allowed, message = gate_course_progress(course)
        if not allowed:
            return Response({"detail": message}, status=status.HTTP_403_FORBIDDEN)
        current_average = calculate_course_average(course)
        progress_percent = calculate_progress_percent(course)
        needed_to_pass = calculate_needed_to_pass(course)
        return Response(
            {
                "course_id": course.id,
                "current_average": current_average,
                "progress_percent": progress_percent,
                "needed_to_pass": needed_to_pass,
            }
        )


class FinishSemesterView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def post(self, request, semester_id):
        semester = get_object_or_404(Semester, pk=semester_id, user=request.user)
        allowed, message = gate_finish_semester(semester)
        if not allowed:
            return Response({"detail": message}, status=status.HTTP_403_FORBIDDEN)

        any_failed = False
        for course in semester.courses.all():
            current_average = calculate_course_average(course)
            course.final_grade = current_average
            update_course_status(course, semester_status=SEMESTER_FINISHED)
            if course.status == COURSE_FAILED:
                any_failed = True
            course.save(update_fields=["final_grade", "status"])

        semester.status = SEMESTER_FINISHED
        semester.save()

        if any_failed:
            CoachLog.objects.create(
                user=request.user,
                trigger_type=COACH_REPROVACAO,
                suggestion_text=(
                    "Identificamos disciplinas reprovadas. Vamos montar um plano de continuidade e recuperar o ritmo."
                ),
            )
            send_message(
                request.user,
                MESSAGE_CARE,
                {
                    "event": "semester_with_fail",
                    "course": "",
                },
                channels=[CHANNEL_IN_APP, CHANNEL_EMAIL],
            )
            send_message(
                request.user,
                MESSAGE_INCENTIVE,
                {
                    "event": "semester_continue",
                    "course": "",
                },
                channels=[CHANNEL_IN_APP, CHANNEL_EMAIL],
            )
        else:
            CoachLog.objects.create(
                user=request.user,
                trigger_type=COACH_SEMESTRE_CONCLUIDO,
                suggestion_text=(
                    "Parabens! Voce concluiu o semestre sem reprovacoes. Continue com esse ritmo."
                ),
            )
            send_message(
                request.user,
                MESSAGE_ACHIEVEMENT,
                {
                    "event": "semester_all_passed",
                    "course": "",
                },
                channels=["IN_APP", "EMAIL"],
            )

        return Response({"detail": "Semestre finalizado."})

----- END FILE: apps/semester/views.py -----

----- BEGIN FILE: apps/ui/apps.py -----
from django.apps import AppConfig


class UiConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "ui"

----- END FILE: apps/ui/apps.py -----

----- BEGIN FILE: apps/ui/forms.py -----
from django import forms
from django.contrib.auth import authenticate, get_user_model
from django.contrib.auth.forms import AuthenticationForm
from django.utils.translation import gettext_lazy as _


class EmailAuthenticationForm(AuthenticationForm):
    error_messages = {
        **AuthenticationForm.error_messages,
        "inactive": _("Confirme seu e-mail para entrar."),
    }

    username = forms.EmailField(
        label=_("Email"),
        widget=forms.EmailInput(attrs={"class": "form-control", "placeholder": "seu.email@universidade.edu"}),
    )
    password = forms.CharField(
        label=_("Senha"),
        widget=forms.PasswordInput(attrs={"class": "form-control", "placeholder": "Sua senha"}),
    )

    def clean(self):
        username = self.cleaned_data.get("username")
        password = self.cleaned_data.get("password")

        if username is not None and password:
            self.user_cache = authenticate(self.request, username=username, password=password)
            if self.user_cache is None:
                user_model = get_user_model()
                user = user_model._default_manager.filter(email__iexact=username).first()
                if user and user.check_password(password) and not user.is_active:
                    raise forms.ValidationError(self.error_messages["inactive"], code="inactive")
                raise self.get_invalid_login_error()
            self.confirm_login_allowed(self.user_cache)

        return self.cleaned_data


# Bloco: Formulario de primeiro acesso
class FirstAccessForm(forms.Form):
    PLAN_FREE = "FREE"
    PLAN_PAID = "PAGO"
    PLAN_CHOICES = [
        (PLAN_FREE, _("Free")),
        (PLAN_PAID, _("Pago")),
    ]

    name = forms.CharField(label=_("Nome"), max_length=255, widget=forms.TextInput(attrs={"class": "form-control"}))
    email = forms.EmailField(label=_("Email"), widget=forms.EmailInput(attrs={"class": "form-control"}))
    phone = forms.CharField(
        label=_("Telefone (WhatsApp)"),
        max_length=30,
        required=False,
        widget=forms.TextInput(attrs={"class": "form-control"}),
    )
    plan = forms.ChoiceField(
        label=_("Plano"),
        choices=PLAN_CHOICES,
        initial=PLAN_FREE,
        widget=forms.Select(attrs={"class": "form-select"}),
    )
    password1 = forms.CharField(
        label=_("Senha"),
        widget=forms.PasswordInput(attrs={"class": "form-control"}),
        min_length=6,
    )
    password2 = forms.CharField(
        label=_("Confirmar senha"),
        widget=forms.PasswordInput(attrs={"class": "form-control"}),
        min_length=6,
    )
    allow_email = forms.BooleanField(
        label=_("Receber email"),
        required=False,
        initial=True,
        widget=forms.CheckboxInput(attrs={"class": "form-check-input"}),
    )
    allow_whatsapp = forms.BooleanField(
        label=_("Receber WhatsApp"),
        required=False,
        initial=True,
        widget=forms.CheckboxInput(attrs={"class": "form-check-input"}),
    )
    allow_sms = forms.BooleanField(
        label=_("Receber SMS"),
        required=False,
        initial=False,
        widget=forms.CheckboxInput(attrs={"class": "form-check-input"}),
    )

    def clean(self):
        data = super().clean()
        if data.get("password1") != data.get("password2"):
            self.add_error("password2", _("As senhas nao conferem."))
        return data

----- END FILE: apps/ui/forms.py -----

----- BEGIN FILE: apps/ui/forms_academic.py -----
from django import forms
from django.core.exceptions import ValidationError
from django.utils.translation import gettext_lazy as _

from semester.models import Assessment, Course, Semester


class SemesterForm(forms.ModelForm):
    class Meta:
        model = Semester
        fields = ["name", "start_date", "end_date", "status"]
        labels = {
            "name": _("Nome do semestre"),
            "start_date": _("Data de inicio"),
            "end_date": _("Data de termino"),
            "status": _("Status"),
        }
        widgets = {
            "name": forms.TextInput(attrs={"class": "form-control"}),
            "start_date": forms.DateInput(attrs={"class": "form-control", "type": "date"}),
            "end_date": forms.DateInput(attrs={"class": "form-control", "type": "date"}),
            "status": forms.Select(attrs={"class": "form-select"}),
        }


class CourseForm(forms.ModelForm):
    class Meta:
        model = Course
        fields = ["title", "teacher", "credits", "passing_grade", "status", "final_grade", "notes"]
        labels = {
            "title": _("Nome da disciplina"),
            "teacher": _("Professor"),
            "credits": _("Creditos"),
            "passing_grade": _("Nota minima"),
            "status": _("Status"),
            "final_grade": _("Nota final"),
            "notes": _("Anotacoes"),
        }
        widgets = {
            "title": forms.TextInput(attrs={"class": "form-control"}),
            "teacher": forms.TextInput(attrs={"class": "form-control"}),
            "credits": forms.NumberInput(attrs={"class": "form-control", "min": 0}),
            "passing_grade": forms.NumberInput(attrs={"class": "form-control", "step": "0.01", "min": 0}),
            "status": forms.Select(attrs={"class": "form-select"}),
            "final_grade": forms.NumberInput(attrs={"class": "form-control", "step": "0.01", "min": 0}),
            "notes": forms.Textarea(attrs={"class": "form-control", "rows": 4}),
        }

    def clean_passing_grade(self):
        passing_grade = self.cleaned_data.get("passing_grade")
        if passing_grade is not None and passing_grade <= 0:
            raise ValidationError(_("A nota minima deve ser maior que zero."))
        return passing_grade


class AssessmentForm(forms.ModelForm):
    class Meta:
        model = Assessment
        fields = ["title", "score", "max_score", "weight", "date"]
        labels = {
            "title": _("Titulo"),
            "score": _("Nota obtida"),
            "max_score": _("Nota maxima"),
            "weight": _("Peso"),
            "date": _("Data"),
        }
        widgets = {
            "title": forms.TextInput(attrs={"class": "form-control"}),
            "score": forms.NumberInput(attrs={"class": "form-control", "step": "0.01", "min": 0}),
            "max_score": forms.NumberInput(attrs={"class": "form-control", "step": "0.01", "min": 0}),
            "weight": forms.NumberInput(attrs={"class": "form-control", "step": "0.01", "min": 0}),
            "date": forms.DateInput(attrs={"class": "form-control", "type": "date"}),
        }

    def clean(self):
        cleaned_data = super().clean()
        score = cleaned_data.get("score")
        max_score = cleaned_data.get("max_score")
        weight = cleaned_data.get("weight")
        if score is not None and max_score is not None and score > max_score:
            raise ValidationError(_("A nota obtida nao pode ser maior que a nota maxima."))
        if weight is not None and weight < 0:
            raise ValidationError(_("O peso deve ser maior ou igual a zero."))
        return cleaned_data

----- END FILE: apps/ui/forms_academic.py -----

----- BEGIN FILE: apps/ui/forms_agenda.py -----
from django import forms
from django.utils.translation import gettext_lazy as _

from agenda.models import CalendarEvent
from planner.models import Task


class CalendarEventForm(forms.ModelForm):
    class Meta:
        model = CalendarEvent
        fields = ["title", "event_type", "start_at", "end_at", "related_task", "notes"]
        labels = {
            "title": _("Titulo"),
            "event_type": _("Tipo"),
            "start_at": _("Inicio"),
            "end_at": _("Fim"),
            "related_task": _("Tarefa relacionada"),
            "notes": _("Observacoes"),
        }
        widgets = {
            "title": forms.TextInput(attrs={"class": "form-control"}),
            "event_type": forms.Select(attrs={"class": "form-select"}),
            "start_at": forms.DateTimeInput(
                attrs={"class": "form-control", "type": "datetime-local"},
                format="%Y-%m-%dT%H:%M",
            ),
            "end_at": forms.DateTimeInput(
                attrs={"class": "form-control", "type": "datetime-local"},
                format="%Y-%m-%dT%H:%M",
            ),
            "related_task": forms.Select(attrs={"class": "form-select"}),
            "notes": forms.Textarea(attrs={"class": "form-control", "rows": 4}),
        }

    def __init__(self, *args, **kwargs):
        user = kwargs.pop("user", None)
        super().__init__(*args, **kwargs)
        self.fields["start_at"].input_formats = ["%Y-%m-%dT%H:%M"]
        self.fields["end_at"].input_formats = ["%Y-%m-%dT%H:%M"]
        if user is not None:
            self.fields["related_task"].queryset = Task.objects.filter(user=user).order_by("due_date")
        self.fields["related_task"].required = False
        self.fields["related_task"].empty_label = _("Estudos")

----- END FILE: apps/ui/forms_agenda.py -----

----- BEGIN FILE: apps/ui/forms_reminders.py -----
from django import forms
from django.core.exceptions import ValidationError
from django.utils.translation import gettext_lazy as _

from agenda.models import ReminderRule
from utils.constants import CHANNEL_EMAIL, CHANNEL_SMS, CHANNEL_WHATSAPP

CHANNEL_OPTIONS = [
    (CHANNEL_EMAIL, "Email"),
    (CHANNEL_WHATSAPP, "WhatsApp"),
    (CHANNEL_SMS, "SMS"),
]


class ReminderRuleForm(forms.ModelForm):
    channels = forms.MultipleChoiceField(
        choices=CHANNEL_OPTIONS,
        widget=forms.CheckboxSelectMultiple,
        label=_("Canais"),
        required=False,
    )

    class Meta:
        model = ReminderRule
        fields = ["target_type", "remind_before_minutes", "channels", "is_active"]
        labels = {
            "target_type": _("Tipo de alvo"),
            "remind_before_minutes": _("Minutos antes"),
            "is_active": _("Ativo"),
        }
        widgets = {
            "target_type": forms.Select(attrs={"class": "form-select"}),
            "remind_before_minutes": forms.NumberInput(attrs={"class": "form-control", "min": 1}),
            "is_active": forms.CheckboxInput(attrs={"class": "form-check-input"}),
        }

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        if self.instance and self.instance.channels:
            self.fields["channels"].initial = self.instance.channels

    def clean_remind_before_minutes(self):
        minutes = self.cleaned_data.get("remind_before_minutes")
        if minutes is not None and minutes <= 0:
            raise ValidationError(_("Informe um valor maior que zero."))
        return minutes

    def save(self, commit=True):
        instance = super().save(commit=False)
        instance.channels = self.cleaned_data.get("channels", [])
        if commit:
            instance.save()
        return instance

----- END FILE: apps/ui/forms_reminders.py -----

----- BEGIN FILE: apps/ui/forms_tasks.py -----
from django import forms
from django.utils.translation import gettext_lazy as _

from planner.models import Task


class TaskForm(forms.ModelForm):
    class Meta:
        model = Task
        fields = ["title", "description", "due_date", "stress_level", "status"]
        labels = {
            "title": _("Titulo"),
            "description": _("Descricao"),
            "due_date": _("Data de entrega"),
            "stress_level": _("Nivel de estresse(0 a 5)"),
            "status": _("Status"),
        }
        widgets = {
            "title": forms.TextInput(attrs={"class": "form-control"}),
            "description": forms.Textarea(attrs={"class": "form-control", "rows": 4}),
            "due_date": forms.DateInput(attrs={"class": "form-control", "type": "date"}),
            "stress_level": forms.NumberInput(attrs={"class": "form-control", "min": 1, "max": 5}),
            "status": forms.Select(attrs={"class": "form-select"}),
        }

----- END FILE: apps/ui/forms_tasks.py -----

----- BEGIN FILE: apps/ui/services_academic.py -----
from utils.academic_progress import (
    calculate_course_average,
    calculate_needed_to_pass,
    calculate_progress_percent,
)


def build_course_progress(course):
    assessments_qs = course.assessments.all()
    has_assessments = assessments_qs.exists()
    current_average = calculate_course_average(course)
    progress_percent = calculate_progress_percent(course)
    needed_to_pass = calculate_needed_to_pass(course)
    return {
        "has_assessments": has_assessments,
        "current_average": current_average,
        "passing_grade": course.passing_grade,
        "progress_percent": progress_percent,
        "needed_to_pass": needed_to_pass,
    }

----- END FILE: apps/ui/services_academic.py -----

----- BEGIN FILE: apps/ui/urls.py -----
from django.contrib.auth import views as auth_views
from django.urls import path

from ui.forms import EmailAuthenticationForm
from ui.views import (
    activate_account_view,
    dashboard_view,
    first_access_view,
    home_view,
    onboarding_view,
    semesters_view,
    tasks_view,
)
from ui.views_academic import (
    assessment_create_view,
    assessment_delete_view,
    assessment_update_view,
    course_create_view,
    course_delete_view,
    course_detail_view,
    course_update_view,
    semester_create_view,
    semester_delete_view,
    semester_detail_view,
    semester_list_view,
    semester_update_view,
)
from ui.views_agenda import agenda_create_view, agenda_delete_view, agenda_list_view, agenda_update_view
from ui.views_messages import message_list_view
from ui.views_reminders import (
    reminder_create_view,
    reminder_delete_view,
    reminder_generate_view,
    reminder_list_view,
    reminder_update_view,
)
from ui.views_tasks import task_create_view, task_delete_view, task_detail_view, task_list_view, task_update_view

urlpatterns = [
    path(
        "login/",
        auth_views.LoginView.as_view(
            template_name="ui/login.html",
            authentication_form=EmailAuthenticationForm,
        ),
        name="ui-login",
    ),
    path("home/", home_view, name="ui-home"),
    path("primeiro-acesso/", first_access_view, name="ui-first-access"),
    path("ativar/<uidb64>/<token>/", activate_account_view, name="ui-activate-account"),
    path("logout/", auth_views.LogoutView.as_view(next_page="/login/"), name="ui-logout"),
    path("logout/", auth_views.LogoutView.as_view(next_page="/login/"), name="logout"),
    path(
        "password-reset/",
        auth_views.PasswordResetView.as_view(
            template_name="ui/password_reset_form.html",
            email_template_name="registration/password_reset_email.html",
            subject_template_name="registration/password_reset_subject.txt",
            success_url="/password-reset/done/",
        ),
        name="password_reset",
    ),
    path(
        "password-reset/done/",
        auth_views.PasswordResetDoneView.as_view(
            template_name="ui/password_reset_done.html",
        ),
        name="password_reset_done",
    ),
    path(
        "reset/<uidb64>/<token>/",
        auth_views.PasswordResetConfirmView.as_view(
            template_name="ui/password_reset_confirm.html",
            success_url="/reset/done/",
        ),
        name="password_reset_confirm",
    ),
    path(
        "reset/done/",
        auth_views.PasswordResetCompleteView.as_view(
            template_name="ui/password_reset_complete.html",
        ),
        name="password_reset_complete",
    ),
    path("", dashboard_view, name="ui-dashboard"),
    path("onboarding/", onboarding_view, name="ui-onboarding"),
    path("semesters/", semesters_view, name="ui-semesters"),
    path("semestres/", semester_list_view, name="ui-semester-list"),
    path("semestres/novo/", semester_create_view, name="ui-semester-create"),
    path("semestres/<int:pk>/", semester_detail_view, name="ui-semester-detail"),
    path("semestres/<int:pk>/editar/", semester_update_view, name="ui-semester-edit"),
    path("semestres/<int:pk>/excluir/", semester_delete_view, name="ui-semester-delete"),
    path("semestres/<int:sem_id>/disciplinas/nova/", course_create_view, name="ui-course-create"),
    path("disciplinas/<int:pk>/", course_detail_view, name="ui-course-detail"),
    path("disciplinas/<int:pk>/editar/", course_update_view, name="ui-course-edit"),
    path("disciplinas/<int:pk>/excluir/", course_delete_view, name="ui-course-delete"),
    path("disciplinas/<int:course_id>/avaliacoes/nova/", assessment_create_view, name="ui-assessment-create"),
    path("avaliacoes/<int:pk>/editar/", assessment_update_view, name="ui-assessment-edit"),
    path("avaliacoes/<int:pk>/excluir/", assessment_delete_view, name="ui-assessment-delete"),
    path("tasks/", task_list_view, name="ui-tasks"),
    path("agenda/", agenda_list_view, name="ui-agenda-list"),
    path("messages/", message_list_view, name="ui-messages"),
    path("tarefas/", task_list_view, name="ui-task-list"),
    path("tarefas/nova/", task_create_view, name="ui-task-create"),
    path("tarefas/<int:pk>/", task_detail_view, name="ui-task-detail"),
    path("tarefas/<int:pk>/editar/", task_update_view, name="ui-task-edit"),
    path("tarefas/<int:pk>/excluir/", task_delete_view, name="ui-task-delete"),
    path("agenda/novo/", agenda_create_view, name="ui-agenda-create"),
    path("agenda/<int:pk>/editar/", agenda_update_view, name="ui-agenda-edit"),
    path("agenda/<int:pk>/excluir/", agenda_delete_view, name="ui-agenda-delete"),
    path("lembretes/", reminder_list_view, name="ui-reminder-list"),
    path("lembretes/gerar/", reminder_generate_view, name="ui-reminder-generate"),
    path("lembretes/novo/", reminder_create_view, name="ui-reminder-create"),
    path("lembretes/<int:pk>/editar/", reminder_update_view, name="ui-reminder-edit"),
    path("lembretes/<int:pk>/excluir/", reminder_delete_view, name="ui-reminder-delete"),
    path("mensagens/", message_list_view, name="ui-message-list"),
]

----- END FILE: apps/ui/urls.py -----

----- BEGIN FILE: apps/ui/views.py -----
from collections import Counter
from datetime import timedelta

from django.conf import settings
from django.contrib import messages
from django.contrib.auth import get_user_model
from django.contrib.auth.decorators import login_required
from django.contrib.auth.tokens import default_token_generator
from django.core.mail import EmailMultiAlternatives
from django.db.models import Q
from django.shortcuts import redirect, render
from django.template.loader import render_to_string
from django.urls import reverse
from django.utils.encoding import force_bytes, force_str
from django.utils.http import urlsafe_base64_decode, urlsafe_base64_encode
from django.utils import timezone
from django.utils.translation import gettext_lazy as _

from accounts.models import UserProfile
from agenda.models import CalendarEvent, ReminderRule
from billing.models import Plan, UserSubscription
from mood.models import MoodEntry
from notifications.models import NotificationQueue
from onboarding.services import refresh_user_progress
from planner.models import Task
from pomodoro.models import PomodoroSession
from semester.models import Course, Semester, SemesterCheckin
from utils.academic_progress import (
    calculate_course_average,
    calculate_needed_to_pass,
    calculate_progress_percent,
    update_course_status,
)
from utils.constants import (
    EVENT_TYPE_CHOICES,
    CHANNEL_IN_APP,
    SEMESTER_ACTIVE,
    SEMESTER_FINISHED,
    TASK_DOING,
    TASK_DONE,
    TASK_TODO,
    PLAN_LITE,
    PLAN_PRO,
)
from utils.gating import STEPS, compute_status
from ui.forms import FirstAccessForm

STEP_LABELS = {
    "STEP_1_PROFILE": _("Perfil"),
    "STEP_2_SEMESTER": _("Semestre"),
    "STEP_3_COURSES": _("Disciplinas"),
    "STEP_4_ASSESSMENTS": _("Avaliacoes"),
    "STEP_5_REMINDERS": _("Lembretes"),
    "STEP_6_DASHBOARD": _("Dashboard"),
}


def home_view(request):
    return render(request, "ui/home.html")


def _build_activation_url(request, uidb64, token):
    activate_path = reverse("ui-activate-account", kwargs={"uidb64": uidb64, "token": token})
    site_base_url = (settings.SITE_BASE_URL or "").strip().rstrip("/")
    if site_base_url:
        return f"{site_base_url}{activate_path}"
    return request.build_absolute_uri(activate_path)


def _send_activation_email(request, user):
    uidb64 = urlsafe_base64_encode(force_bytes(user.pk))
    token = default_token_generator.make_token(user)
    activation_url = _build_activation_url(request, uidb64, token)
    context = {"user": user, "activation_url": activation_url}

    subject = _("Ative sua conta no CampusCalm")
    text_body = render_to_string("accounts/email/activate_account.txt", context)
    html_body = render_to_string("accounts/email/activate_account.html", context)

    email = EmailMultiAlternatives(
        subject=subject,
        body=text_body,
        from_email=settings.DEFAULT_FROM_EMAIL,
        to=[user.email],
    )
    email.attach_alternative(html_body, "text/html")
    email.send(fail_silently=False)


def _build_steps(progress):
    current_step, missing_steps, required_actions = compute_status(progress)
    steps = []
    for step, _field, message in STEPS:
        label = STEP_LABELS.get(step, step)
        is_missing = step in missing_steps
        steps.append(
            {
                "code": step,
                "label": label,
                "missing": is_missing,
                "message": message if is_missing else _("Concluido"),
            }
        )
    total_steps = len(steps)
    completed_steps = total_steps - len(missing_steps)
    progress_percent = int((completed_steps / total_steps) * 100) if total_steps else 0
    return {
        "current_step": current_step,
        "missing_steps": missing_steps,
        "required_actions": required_actions,
        "steps": steps,
        "is_complete": len(missing_steps) == 0,
        "total_steps": total_steps,
        "completed_steps": completed_steps,
        "progress_percent": progress_percent,
    }


# Bloco: Primeiro acesso / Criar conta
def first_access_view(request):
    user_model = get_user_model()
    if request.method == "POST":
        form = FirstAccessForm(request.POST)
        if form.is_valid():
            email = form.cleaned_data["email"].lower()
            if user_model.objects.filter(email=email).exists():
                form.add_error("email", _("Ja existe um usuario com este email."))
                return render(request, "ui/first_access.html", {"form": form})

            user = user_model.objects.create_user(
                email=email,
                name=form.cleaned_data["name"],
                phone_number=form.cleaned_data.get("phone", ""),
                password=form.cleaned_data["password1"],
                is_active=False,
            )

            profile = UserProfile.objects.get_or_create(user=user)[0]
            profile.phone = form.cleaned_data.get("phone", "")
            profile.plan = form.cleaned_data["plan"]
            profile.allow_email = form.cleaned_data.get("allow_email", True)
            profile.allow_whatsapp = form.cleaned_data.get("allow_whatsapp", True)
            profile.allow_sms = form.cleaned_data.get("allow_sms", False)
            profile.consent_at = timezone.now()
            profile.save()

            plan_code = PLAN_PRO if profile.plan == UserProfile.PLAN_PAID else PLAN_LITE
            plan = Plan.objects.filter(code=plan_code, is_active=True).first()
            if plan:
                UserSubscription.objects.get_or_create(user=user, defaults={"plan": plan})

            _send_activation_email(request, user)
            messages.success(request, _("Enviamos um link de ativacao para seu e-mail."))
            return redirect("ui-login")
    else:
        form = FirstAccessForm()
    return render(request, "ui/first_access.html", {"form": form})


def activate_account_view(request, uidb64, token):
    user_model = get_user_model()
    user = None
    try:
        uid = force_str(urlsafe_base64_decode(uidb64))
        user = user_model.objects.get(pk=uid)
    except (TypeError, ValueError, OverflowError, user_model.DoesNotExist):
        user = None

    if user and default_token_generator.check_token(user, token):
        if not user.is_active:
            user.is_active = True
            user.save(update_fields=["is_active"])
            messages.success(request, _("Conta ativada com sucesso. Agora voce pode entrar."))
        else:
            messages.info(request, _("Sua conta ja esta ativada."))
    else:
        messages.error(request, _("Link de ativacao invalido ou expirado."))
    return redirect("ui-login")


@login_required(login_url="/login/")
def dashboard_view(request):
    user = request.user
    progress = refresh_user_progress(user)
    onboarding_status = _build_steps(progress)

    session_key = "ui_dashboard_filters"
    if request.GET.get("clear") == "1":
        request.session.pop(session_key, None)
        return redirect(request.path)
    if "q" in request.GET:
        search_query = request.GET.get("q", "").strip()
        request.session[session_key] = {"q": search_query}
    else:
        search_query = request.session.get(session_key, {}).get("q", "")

    now = timezone.now()
    week_ago = now - timedelta(days=7)

    mood_entries = MoodEntry.objects.filter(user=user, created_at__gte=week_ago)
    mood_counts = Counter(mood_entries.values_list("mood", flat=True))
    most_common_mood = None
    if mood_counts:
        most_common_mood = mood_counts.most_common(1)[0][0]

    focus_minutes = (
        PomodoroSession.objects.filter(user=user, started_at__gte=week_ago)
        .values_list("focus_minutes", flat=True)
    )
    total_focus_minutes = sum(focus_minutes)

    stress_values = SemesterCheckin.objects.filter(semester__user=user, created_at__gte=week_ago).values_list(
        "overall_stress", flat=True
    )
    stress_avg = round(sum(stress_values) / len(stress_values), 2) if stress_values else None

    today = timezone.localdate()
    next_week = today + timedelta(days=7)
    upcoming_tasks = Task.objects.filter(user=user, due_date__gte=today, due_date__lte=next_week).order_by("due_date")
    upcoming_events = CalendarEvent.objects.filter(
        user=user, start_at__date__gte=today, start_at__date__lte=next_week
    ).order_by("start_at")
    if search_query:
        upcoming_tasks = upcoming_tasks.filter(Q(title__icontains=search_query) | Q(description__icontains=search_query))
        upcoming_events = upcoming_events.filter(title__icontains=search_query)

    tasks = Task.objects.filter(user=user)
    courses = Course.objects.filter(semester__user=user).select_related("semester").order_by("title")
    course_progress = []
    for course in courses:
        course_progress.append(
            {
                "title": course.title,
                "semester": course.semester.name,
                "current_average": calculate_course_average(course),
                "passing_grade": course.passing_grade,
                "progress_percent": int(calculate_progress_percent(course)),
            }
        )
    dashboard_data = {
        "tasks": {
            "todo": tasks.filter(status=TASK_TODO).count(),
            "doing": tasks.filter(status=TASK_DOING).count(),
            "done": tasks.filter(status=TASK_DONE).count(),
        },
        "mood_weekly_total": mood_entries.count(),
        "mood_most_common": most_common_mood,
        "focus_minutes_week": total_focus_minutes,
        "stress_avg_week": stress_avg,
        "upcoming_tasks": upcoming_tasks[:5],
        "upcoming_events": upcoming_events[:5],
        "upcoming_count": upcoming_tasks.count() + upcoming_events.count(),
        "course_progress": course_progress[:5],
    }

    return render(
        request,
        "ui/dashboard.html",
        {
            "onboarding_status": onboarding_status,
            "dashboard_data": dashboard_data,
            "search_query": search_query,
        },
    )


@login_required(login_url="/login/")
def onboarding_view(request):
    user = request.user
    progress = refresh_user_progress(user)
    onboarding_status = _build_steps(progress)
    return render(
        request,
        "ui/onboarding.html",
        {
            "current_step": onboarding_status["current_step"],
            "missing_steps": onboarding_status["missing_steps"],
            "required_actions": onboarding_status["required_actions"],
            "steps": onboarding_status["steps"],
        },
    )


@login_required(login_url="/login/")
def semesters_view(request):
    user = request.user
    session_key = "ui_semesters_filters"
    if request.GET.get("clear") == "1":
        request.session.pop(session_key, None)
        return redirect(request.path)
    if any(key in request.GET for key in ("status", "course", "teacher")):
        status_filter = request.GET.get("status", "")
        course_query = request.GET.get("course", "").strip()
        teacher_query = request.GET.get("teacher", "").strip()
        request.session[session_key] = {
            "status": status_filter,
            "course": course_query,
            "teacher": teacher_query,
        }
    else:
        saved = request.session.get(session_key, {})
        status_filter = saved.get("status", "")
        course_query = saved.get("course", "")
        teacher_query = saved.get("teacher", "")
    semesters = Semester.objects.filter(user=user)
    if status_filter in {SEMESTER_ACTIVE, SEMESTER_FINISHED}:
        semesters = semesters.filter(status=status_filter)
    semesters = semesters.order_by("-start_date")
    semester_cards = []
    for semester in semesters.prefetch_related("courses__assessments"):
        courses_data = []
        for course in semester.courses.all():
            if course_query and course_query.lower() not in course.title.lower():
                continue
            if teacher_query and teacher_query.lower() not in (course.teacher or "").lower():
                continue
            current_average = calculate_course_average(course)
            progress_percent = calculate_progress_percent(course)
            progress_value = float(progress_percent)
            progress_display = f"{progress_value:.2f}"
            needed_to_pass = calculate_needed_to_pass(course)
            previous_status = course.status
            update_course_status(course, semester_status=semester.status)
            if course.status != previous_status:
                course.save(update_fields=["status"])
            courses_data.append(
                {
                    "title": course.title,
                    "teacher": course.teacher,
                    "status": course.status,
                    "passing_grade": course.passing_grade,
                    "current_average": current_average,
                    "progress_percent": progress_display,
                    "progress_percent_css": progress_display,
                    "needed_to_pass": needed_to_pass,
                }
            )
        if (course_query or teacher_query) and not courses_data:
            continue
        semester_cards.append(
            {
                "name": semester.name,
                "start_date": semester.start_date,
                "end_date": semester.end_date,
                "status": semester.status,
                "courses": courses_data,
            }
        )

    return render(
        request,
        "ui/semesters.html",
        {
            "semesters": semester_cards,
            "status_filter": status_filter,
            "course_query": course_query,
            "teacher_query": teacher_query,
        },
    )


@login_required(login_url="/login/")
def tasks_view(request):
    user = request.user
    session_key = "ui_tasks_filters"
    if request.GET.get("clear") == "1":
        request.session.pop(session_key, None)
        return redirect(request.path)
    if any(key in request.GET for key in ("status", "due", "q", "stress")):
        status_filter = request.GET.get("status", "")
        due_filter = request.GET.get("due", "")
        search_query = request.GET.get("q", "").strip()
        stress_filter = request.GET.get("stress", "")
        request.session[session_key] = {
            "status": status_filter,
            "due": due_filter,
            "q": search_query,
            "stress": stress_filter,
        }
    else:
        saved = request.session.get(session_key, {})
        status_filter = saved.get("status", "")
        due_filter = saved.get("due", "")
        search_query = saved.get("q", "")
        stress_filter = saved.get("stress", "")
    tasks = Task.objects.filter(user=user)
    if status_filter in {TASK_TODO, TASK_DOING, TASK_DONE}:
        tasks = tasks.filter(status=status_filter)
    today = timezone.localdate()
    if due_filter == "overdue":
        tasks = tasks.filter(due_date__lt=today)
    elif due_filter == "today":
        tasks = tasks.filter(due_date=today)
    elif due_filter == "week":
        tasks = tasks.filter(due_date__gte=today, due_date__lte=today + timedelta(days=7))
    elif due_filter == "month":
        tasks = tasks.filter(due_date__gte=today, due_date__lte=today + timedelta(days=30))
    if search_query:
        tasks = tasks.filter(Q(title__icontains=search_query) | Q(description__icontains=search_query))
    if stress_filter in {"1", "2", "3", "4", "5"}:
        tasks = tasks.filter(stress_level=int(stress_filter))
    tasks = tasks.order_by("due_date")
    return render(
        request,
        "ui/tasks.html",
        {
            "tasks": tasks,
            "status_filter": status_filter,
            "due_filter": due_filter,
            "search_query": search_query,
            "stress_filter": stress_filter,
        },
    )


@login_required(login_url="/login/")
def agenda_view(request):
    user = request.user
    today = timezone.localdate()
    session_key = "ui_agenda_filters"
    if request.GET.get("clear") == "1":
        request.session.pop(session_key, None)
        return redirect(request.path)
    if any(key in request.GET for key in ("range", "q", "type")):
        range_days = request.GET.get("range", "30")
        if range_days not in {"7", "15", "30", "60", "90"}:
            range_days = "30"
        search_query = request.GET.get("q", "").strip()
        type_filter = request.GET.get("type", "")
        request.session[session_key] = {
            "range": range_days,
            "q": search_query,
            "type": type_filter,
        }
    else:
        saved = request.session.get(session_key, {})
        range_days = saved.get("range", "30")
        search_query = saved.get("q", "")
        type_filter = saved.get("type", "")
    next_month = today + timedelta(days=int(range_days))
    events = CalendarEvent.objects.filter(
        user=user, start_at__date__gte=today, start_at__date__lte=next_month
    ).order_by("start_at")
    if search_query:
        events = events.filter(title__icontains=search_query)
    event_type_values = [value for value, _label in EVENT_TYPE_CHOICES]
    if type_filter in event_type_values:
        events = events.filter(event_type=type_filter)
    reminder_rules = ReminderRule.objects.filter(user=user, is_active=True)
    return render(
        request,
        "ui/agenda.html",
        {
            "events": events,
            "reminder_rules": reminder_rules,
            "range_days": range_days,
            "search_query": search_query,
            "type_filter": type_filter,
            "event_type_choices": EVENT_TYPE_CHOICES,
        },
    )


@login_required(login_url="/login/")
def messages_view(request):
    user = request.user
    notifications = NotificationQueue.objects.filter(user=user, channel=CHANNEL_IN_APP).order_by("-scheduled_for")
    return render(
        request,
        "ui/messages.html",
        {
            "notifications": notifications,
        },
    )

----- END FILE: apps/ui/views.py -----

----- BEGIN FILE: apps/ui/views_academic.py -----
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.shortcuts import get_object_or_404, redirect, render
from django.utils.translation import gettext_lazy as _

from semester.models import Assessment, Course, Semester
from ui.forms_academic import AssessmentForm, CourseForm, SemesterForm
from ui.services_academic import build_course_progress


@login_required(login_url="/login/")
def semester_list_view(request):
    semesters = Semester.objects.filter(user=request.user).order_by("-start_date")
    return render(request, "ui/semester/semester_list.html", {"semesters": semesters})


@login_required(login_url="/login/")
def semester_create_view(request):
    if request.method == "POST":
        form = SemesterForm(request.POST)
        if form.is_valid():
            semester = form.save(commit=False)
            semester.user = request.user
            semester.save()
            messages.success(request, _("Semestre criado com sucesso."))
            return redirect("ui-semester-detail", pk=semester.pk)
    else:
        form = SemesterForm()
    return render(request, "ui/semester/semester_form.html", {"form": form, "mode": "create"})


@login_required(login_url="/login/")
def semester_detail_view(request, pk: int):
    semester = get_object_or_404(Semester, pk=pk, user=request.user)
    courses = semester.courses.all().order_by("title")
    return render(
        request,
        "ui/semester/semester_detail.html",
        {"semester": semester, "courses": courses},
    )


@login_required(login_url="/login/")
def semester_update_view(request, pk: int):
    semester = get_object_or_404(Semester, pk=pk, user=request.user)
    if request.method == "POST":
        form = SemesterForm(request.POST, instance=semester)
        if form.is_valid():
            form.save()
            messages.success(request, _("Semestre atualizado com sucesso."))
            return redirect("ui-semester-detail", pk=semester.pk)
    else:
        form = SemesterForm(instance=semester)
    return render(
        request,
        "ui/semester/semester_form.html",
        {"form": form, "semester": semester, "mode": "edit"},
    )


@login_required(login_url="/login/")
def semester_delete_view(request, pk: int):
    semester = get_object_or_404(Semester, pk=pk, user=request.user)
    if request.method == "POST":
        semester.delete()
        messages.success(request, _("Semestre excluido com sucesso."))
        return redirect("ui-semester-list")
    return render(
        request,
        "ui/semester/semester_confirm_delete.html",
        {"semester": semester},
    )


@login_required(login_url="/login/")
def course_create_view(request, sem_id: int):
    semester = get_object_or_404(Semester, pk=sem_id, user=request.user)
    if request.method == "POST":
        form = CourseForm(request.POST)
        if form.is_valid():
            course = form.save(commit=False)
            course.semester = semester
            course.save()
            messages.success(request, _("Disciplina criada com sucesso."))
            return redirect("ui-course-detail", pk=course.pk)
    else:
        form = CourseForm()
    return render(
        request,
        "ui/course/course_form.html",
        {"form": form, "semester": semester, "mode": "create"},
    )


@login_required(login_url="/login/")
def course_detail_view(request, pk: int):
    course = get_object_or_404(Course, pk=pk, semester__user=request.user)
    assessments = course.assessments.all().order_by("-date", "-created_at")
    progress = build_course_progress(course)
    return render(
        request,
        "ui/course/course_detail.html",
        {"course": course, "assessments": assessments, "progress": progress},
    )


@login_required(login_url="/login/")
def course_update_view(request, pk: int):
    course = get_object_or_404(Course, pk=pk, semester__user=request.user)
    if request.method == "POST":
        form = CourseForm(request.POST, instance=course)
        if form.is_valid():
            form.save()
            messages.success(request, _("Disciplina atualizada com sucesso."))
            return redirect("ui-course-detail", pk=course.pk)
    else:
        form = CourseForm(instance=course)
    return render(
        request,
        "ui/course/course_form.html",
        {"form": form, "course": course, "semester": course.semester, "mode": "edit"},
    )


@login_required(login_url="/login/")
def course_delete_view(request, pk: int):
    course = get_object_or_404(Course, pk=pk, semester__user=request.user)
    if request.method == "POST":
        semester_id = course.semester_id
        course.delete()
        messages.success(request, _("Disciplina excluida com sucesso."))
        return redirect("ui-semester-detail", pk=semester_id)
    return render(
        request,
        "ui/course/course_confirm_delete.html",
        {"course": course},
    )


@login_required(login_url="/login/")
def assessment_create_view(request, course_id: int):
    course = get_object_or_404(Course, pk=course_id, semester__user=request.user)
    if request.method == "POST":
        form = AssessmentForm(request.POST)
        if form.is_valid():
            assessment = form.save(commit=False)
            assessment.course = course
            assessment.save()
            messages.success(request, _("Avaliacao criada com sucesso."))
            return redirect("ui-course-detail", pk=course.pk)
    else:
        form = AssessmentForm()
    return render(
        request,
        "ui/assessment/assessment_form.html",
        {"form": form, "course": course, "mode": "create"},
    )


@login_required(login_url="/login/")
def assessment_update_view(request, pk: int):
    assessment = get_object_or_404(Assessment, pk=pk, course__semester__user=request.user)
    if request.method == "POST":
        form = AssessmentForm(request.POST, instance=assessment)
        if form.is_valid():
            form.save()
            messages.success(request, _("Avaliacao atualizada com sucesso."))
            return redirect("ui-course-detail", pk=assessment.course_id)
    else:
        form = AssessmentForm(instance=assessment)
    return render(
        request,
        "ui/assessment/assessment_form.html",
        {"form": form, "course": assessment.course, "assessment": assessment, "mode": "edit"},
    )


@login_required(login_url="/login/")
def assessment_delete_view(request, pk: int):
    assessment = get_object_or_404(Assessment, pk=pk, course__semester__user=request.user)
    if request.method == "POST":
        course_id = assessment.course_id
        assessment.delete()
        messages.success(request, _("Avaliacao excluida com sucesso."))
        return redirect("ui-course-detail", pk=course_id)
    return render(
        request,
        "ui/assessment/assessment_confirm_delete.html",
        {"assessment": assessment, "course": assessment.course},
    )

----- END FILE: apps/ui/views_academic.py -----

----- BEGIN FILE: apps/ui/views_agenda.py -----
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.shortcuts import get_object_or_404, redirect, render
from django.utils import timezone
from django.utils.translation import gettext_lazy as _

from agenda.models import CalendarEvent
from notifications.services.reminder_queue import create_notifications_for_event
from ui.forms_agenda import CalendarEventForm


@login_required(login_url="/login/")
def agenda_list_view(request):
    events = CalendarEvent.objects.filter(user=request.user).order_by("start_at")
    return render(
        request,
        "ui/agenda/agenda_list.html",
        {
            "events": events,
            "now": timezone.now(),
        },
    )


@login_required(login_url="/login/")
def agenda_create_view(request):
    if request.method == "POST":
        form = CalendarEventForm(request.POST, user=request.user)
        if form.is_valid():
            event = form.save(commit=False)
            event.user = request.user
            event.save()
            # Bloco: Criacao de lembretes para evento
            create_notifications_for_event(request.user, event)
            messages.success(request, _("Evento criado com sucesso."))
            return redirect("ui-agenda-list")
    else:
        form = CalendarEventForm(user=request.user)
    return render(request, "ui/agenda/agenda_form.html", {"form": form, "mode": "create"})


@login_required(login_url="/login/")
def agenda_update_view(request, pk: int):
    event = get_object_or_404(CalendarEvent, pk=pk, user=request.user)
    if request.method == "POST":
        form = CalendarEventForm(request.POST, instance=event, user=request.user)
        if form.is_valid():
            event = form.save()
            # Bloco: Atualizacao de lembretes para evento
            create_notifications_for_event(request.user, event)
            messages.success(request, _("Evento atualizado com sucesso."))
            return redirect("ui-agenda-list")
    else:
        form = CalendarEventForm(instance=event, user=request.user)
    return render(request, "ui/agenda/agenda_form.html", {"form": form, "mode": "edit", "event": event})


@login_required(login_url="/login/")
def agenda_delete_view(request, pk: int):
    event = get_object_or_404(CalendarEvent, pk=pk, user=request.user)
    if request.method == "POST":
        event.delete()
        messages.success(request, _("Evento excluido com sucesso."))
        return redirect("ui-agenda-list")
    return render(request, "ui/agenda/agenda_confirm_delete.html", {"event": event})

----- END FILE: apps/ui/views_agenda.py -----

----- BEGIN FILE: apps/ui/views_messages.py -----
from django.contrib.auth.decorators import login_required
from django.shortcuts import render
from django.utils.translation import gettext_lazy as _

from notifications.models import NotificationQueue
from utils.constants import CHANNEL_CHOICES, NOTIFICATION_STATUS_CHOICES


@login_required(login_url="/login/")
def message_list_view(request):
    status_filter = request.GET.get("status", "")
    channel_filter = request.GET.get("channel", "")

    notifications = NotificationQueue.objects.filter(user=request.user)
    if status_filter:
        notifications = notifications.filter(status=status_filter)
    if channel_filter:
        notifications = notifications.filter(channel=channel_filter)

    notifications = notifications.order_by("-scheduled_for", "-created_at")

    return render(
        request,
        "ui/messages/message_list.html",
        {
            "notifications": notifications,
            "status_filter": status_filter,
            "channel_filter": channel_filter,
            "status_choices": NOTIFICATION_STATUS_CHOICES,
            "channel_choices": CHANNEL_CHOICES,
        },
    )

----- END FILE: apps/ui/views_messages.py -----

----- BEGIN FILE: apps/ui/views_reminders.py -----
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.shortcuts import get_object_or_404, redirect, render
from django.utils.translation import gettext_lazy as _

from agenda.models import ReminderRule
from notifications.services.reminder_queue import create_notifications_for_user
from ui.forms_reminders import ReminderRuleForm


@login_required(login_url="/login/")
def reminder_list_view(request):
    reminders = ReminderRule.objects.filter(user=request.user).order_by("-is_active", "remind_before_minutes")
    return render(request, "ui/reminders/reminder_list.html", {"reminders": reminders})


# Bloco: Gerar lembretes via interface web
@login_required(login_url="/login/")
def reminder_generate_view(request):
    if request.method != "POST":
        return redirect("ui-reminder-list")

    created = create_notifications_for_user(request.user)
    if created:
        messages.success(request, _("Lembretes gerados com sucesso."))
    else:
        messages.info(request, _("Nenhum lembrete novo foi gerado."))
    return redirect("ui-reminder-list")


@login_required(login_url="/login/")
def reminder_create_view(request):
    if request.method == "POST":
        form = ReminderRuleForm(request.POST)
        if form.is_valid():
            reminder = form.save(commit=False)
            reminder.user = request.user
            reminder.save()
            messages.success(request, _("Regra de lembrete criada com sucesso."))
            return redirect("ui-reminder-list")
    else:
        form = ReminderRuleForm()
    return render(request, "ui/reminders/reminder_form.html", {"form": form, "mode": "create"})


@login_required(login_url="/login/")
def reminder_update_view(request, pk: int):
    reminder = get_object_or_404(ReminderRule, pk=pk, user=request.user)
    if request.method == "POST":
        form = ReminderRuleForm(request.POST, instance=reminder)
        if form.is_valid():
            form.save()
            messages.success(request, _("Regra de lembrete atualizada com sucesso."))
            return redirect("ui-reminder-list")
    else:
        form = ReminderRuleForm(instance=reminder)
    return render(
        request,
        "ui/reminders/reminder_form.html",
        {"form": form, "mode": "edit", "reminder": reminder},
    )


@login_required(login_url="/login/")
def reminder_delete_view(request, pk: int):
    reminder = get_object_or_404(ReminderRule, pk=pk, user=request.user)
    if request.method == "POST":
        reminder.delete()
        messages.success(request, _("Regra de lembrete excluida com sucesso."))
        return redirect("ui-reminder-list")
    return render(request, "ui/reminders/reminder_confirm_delete.html", {"reminder": reminder})

----- END FILE: apps/ui/views_reminders.py -----

----- BEGIN FILE: apps/ui/views_tasks.py -----
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.db.models import Q
from django.shortcuts import get_object_or_404, redirect, render
from django.utils.translation import gettext_lazy as _

from notifications.services.reminder_queue import create_notifications_for_task
from planner.models import Task
from ui.forms_tasks import TaskForm
from utils.constants import TASK_DONE, TASK_DOING, TASK_TODO


@login_required(login_url="/login/")
def task_list_view(request):
    tasks = Task.objects.filter(user=request.user)
    status_filter = request.GET.get("status", "")
    query = request.GET.get("q", "").strip()

    if status_filter in {TASK_TODO, TASK_DOING, TASK_DONE}:
        tasks = tasks.filter(status=status_filter)
    if query:
        tasks = tasks.filter(Q(title__icontains=query) | Q(description__icontains=query))

    tasks = tasks.order_by("due_date")

    return render(
        request,
        "ui/tasks/task_list.html",
        {
            "tasks": tasks,
            "status_filter": status_filter,
            "query": query,
        },
    )


@login_required(login_url="/login/")
def task_create_view(request):
    if request.method == "POST":
        form = TaskForm(request.POST)
        if form.is_valid():
            task = form.save(commit=False)
            task.user = request.user
            task.save()
            # Bloco: Criacao de lembretes para tarefa
            create_notifications_for_task(request.user, task)
            messages.success(request, _("Tarefa criada com sucesso."))
            return redirect("ui-task-detail", pk=task.pk)
    else:
        form = TaskForm()
    return render(request, "ui/tasks/task_form.html", {"form": form, "mode": "create"})


@login_required(login_url="/login/")
def task_detail_view(request, pk: int):
    task = get_object_or_404(Task, pk=pk, user=request.user)
    return render(request, "ui/tasks/task_detail.html", {"task": task})


@login_required(login_url="/login/")
def task_update_view(request, pk: int):
    task = get_object_or_404(Task, pk=pk, user=request.user)
    if request.method == "POST":
        form = TaskForm(request.POST, instance=task)
        if form.is_valid():
            task = form.save()
            # Bloco: Atualizacao de lembretes para tarefa
            create_notifications_for_task(request.user, task)
            messages.success(request, _("Tarefa atualizada com sucesso."))
            return redirect("ui-task-detail", pk=task.pk)
    else:
        form = TaskForm(instance=task)
    return render(request, "ui/tasks/task_form.html", {"form": form, "mode": "edit", "task": task})


@login_required(login_url="/login/")
def task_delete_view(request, pk: int):
    task = get_object_or_404(Task, pk=pk, user=request.user)
    if request.method == "POST":
        task.delete()
        messages.success(request, _("Tarefa excluida com sucesso."))
        return redirect("ui-task-list")
    return render(request, "ui/tasks/task_confirm_delete.html", {"task": task})

----- END FILE: apps/ui/views_tasks.py -----

----- BEGIN FILE: config/asgi.py -----
"""
ASGI config for config project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_asgi_application()

----- END FILE: config/asgi.py -----

----- BEGIN FILE: config/settings.py -----
"""
Django settings for campus_calm project.
"""

import os
import sys
from pathlib import Path

from django.utils.translation import gettext_lazy as _

BASE_DIR = Path(__file__).resolve().parent.parent

# Ensure /apps is on the path for INSTALLED_APPS like "accounts"
sys.path.insert(0, str(BASE_DIR / "apps"))

SECRET_KEY = os.getenv("DJANGO_SECRET_KEY", "django-insecure-dev-key")
DEBUG = os.getenv("DJANGO_DEBUG", "True").lower() == "true"
_allowed_hosts_env = [host for host in os.getenv("DJANGO_ALLOWED_HOSTS", "").split(",") if host]
if _allowed_hosts_env:
    ALLOWED_HOSTS = _allowed_hosts_env
elif DEBUG:
    ALLOWED_HOSTS = ["localhost", "127.0.0.1", "[::1]", ".ngrok-free.app", ".ngrok-free.dev", ".ngrok.io"]
else:
    ALLOWED_HOSTS = []

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "corsheaders",
    "rest_framework",
    "rest_framework_simplejwt",
    "drf_spectacular",
    "accounts",
    "billing.apps.BillingConfig",
    "mood",
    "pomodoro",
    "planner",
    "agenda",
    "semester",
    "content",
    "coach_ai",
    "brain",
    "notifications",
    "access_requests",
    "onboarding.apps.OnboardingConfig",
    "analytics",
    "ui.apps.UiConfig",
]

MIDDLEWARE = [
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.locale.LocaleMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

ROOT_URLCONF = "config.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    }
]

WSGI_APPLICATION = "config.wsgi.application"

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "db.sqlite3",
    }
}

AUTH_PASSWORD_VALIDATORS = [
    {"NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator"},
    {"NAME": "django.contrib.auth.password_validation.MinimumLengthValidator"},
    {"NAME": "django.contrib.auth.password_validation.CommonPasswordValidator"},
    {"NAME": "django.contrib.auth.password_validation.NumericPasswordValidator"},
]

LANGUAGE_CODE = "pt-br"
TIME_ZONE = "America/Sao_Paulo"
USE_I18N = True
USE_TZ = True
LANGUAGES = [
    ("en", _("English")),
    ("pt-br", _("Portugus (Brasil)")),
    ("pt-pt", _("Portugus (Portugal)")),
]
LOCALE_PATHS = [BASE_DIR / "locale"]

STATIC_URL = "/static/"
STATICFILES_DIRS = [BASE_DIR / "static"]

MEDIA_URL = "/media/"
MEDIA_ROOT = BASE_DIR / "media"

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"
AUTH_USER_MODEL = "accounts.User"

REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": (
        "rest_framework_simplejwt.authentication.JWTAuthentication",
    ),
    "DEFAULT_PERMISSION_CLASSES": ("rest_framework.permissions.IsAuthenticated",),
    "DEFAULT_SCHEMA_CLASS": "drf_spectacular.openapi.AutoSchema",
}

SPECTACULAR_SETTINGS = {
    "TITLE": "Campus Calm API",
    "DESCRIPTION": "API do MVP Campus Calm",
    "VERSION": "0.1.0",
}

CORS_ALLOW_ALL_ORIGINS = True

EMAIL_BACKEND = "django.core.mail.backends.console.EmailBackend"
DEFAULT_FROM_EMAIL = os.getenv("DEFAULT_FROM_EMAIL", "no-reply@campuscalm.local")

LOGIN_URL = "/login/"
LOGIN_REDIRECT_URL = "/"
LOGOUT_REDIRECT_URL = "/login/"

# Bloco: WhatsApp Cloud API
WHATSAPP_CLOUD_TOKEN = os.getenv("WHATSAPP_CLOUD_TOKEN", "")
WHATSAPP_PHONE_NUMBER_ID = os.getenv("WHATSAPP_PHONE_NUMBER_ID", "")
WHATSAPP_VERIFY_TOKEN = os.getenv("WHATSAPP_VERIFY_TOKEN", "")
SITE_BASE_URL = os.getenv("SITE_BASE_URL", "")

# Brain contextual memory settings (MVP 1.4)
BRAIN_MEMORY_HOURS = 48
BRAIN_HISTORY_LIMIT = 10
BRAIN_STRESS_REPEAT_THRESHOLD = 3
BRAIN_EVOLUCAO_REPEAT_THRESHOLD = 2
BRAIN_STRESS_TO_EVOLUCAO_WINDOW_HOURS = 24

if DEBUG:
    CSRF_TRUSTED_ORIGINS = [
        "https://*.ngrok-free.app",
        "https://*.ngrok-free.dev",
        "https://*.ngrok.io",
    ]

----- END FILE: config/settings.py -----

----- BEGIN FILE: config/settings_migrations.py -----
"""Settings file for generating migrations without third-party dependencies."""

import os
import sys
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent
sys.path.insert(0, str(BASE_DIR / "apps"))

SECRET_KEY = "migration-only"
DEBUG = True
ALLOWED_HOSTS = []

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "accounts",
    "billing.apps.BillingConfig",
    "mood",
    "pomodoro",
    "planner",
    "agenda",
    "semester",
    "content",
    "coach_ai",
    "brain",
    "notifications",
    "access_requests",
    "onboarding.apps.OnboardingConfig",
    "analytics",
    "ui.apps.UiConfig",
]

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

ROOT_URLCONF = "config.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    }
]

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "db.sqlite3",
    }
}

LANGUAGE_CODE = "pt-br"
TIME_ZONE = "America/Sao_Paulo"
USE_I18N = True
USE_TZ = True

STATIC_URL = "/static/"
MEDIA_URL = "/media/"
MEDIA_ROOT = BASE_DIR / "media"

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"
AUTH_USER_MODEL = "accounts.User"

----- END FILE: config/settings_migrations.py -----

----- BEGIN FILE: config/urls.py -----
from django.conf import settings
from django.conf.urls.static import static
from django.contrib import admin
from django.urls import include, path
from drf_spectacular.views import SpectacularAPIView, SpectacularSwaggerView

from config.views import health_check

urlpatterns = [
    path("admin/", admin.site.urls),
    path("health/", health_check, name="health-check"),
    path("i18n/", include("django.conf.urls.i18n")),
    path("", include("ui.urls")),
    path("api/schema/", SpectacularAPIView.as_view(), name="schema"),
    path("api/docs/", SpectacularSwaggerView.as_view(url_name="schema"), name="docs"),
    path("api/auth/", include("accounts.urls")),
    path("api/billing/", include("billing.urls")),
    path("api/mood/", include("mood.urls")),
    path("api/pomodoro/", include("pomodoro.urls")),
    path("api/planner/", include("planner.urls")),
    path("api/agenda/", include("agenda.urls")),
    path("api/semester/", include("semester.urls")),
    path("api/content/", include("content.urls")),
    path("api/widget/", include("brain.urls")),
    path("api/notifications/", include("notifications.urls")),
    path("api/access/", include("access_requests.urls")),
    path("api/onboarding/", include("onboarding.urls")),
    path("api/analytics/", include("analytics.urls")),
]

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

----- END FILE: config/urls.py -----

----- BEGIN FILE: config/views.py -----
from django.http import JsonResponse
from django.utils import timezone


def health_check(_request):
    return JsonResponse({"status": "ok", "timestamp": timezone.now().isoformat()})

----- END FILE: config/views.py -----

----- BEGIN FILE: config/wsgi.py -----
"""
WSGI config for config project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_wsgi_application()

----- END FILE: config/wsgi.py -----

----- BEGIN FILE: docs/TESTE_NOTIFICACOES.md -----
# Teste de Notificacoes (MVP)

Checklist para validar email e WhatsApp em ambiente de teste:

1. Acessar `/login/` e clicar em **Primeiro acesso / Criar conta**.
2. Criar conta com telefone e permitir WhatsApp.
3. Fazer login.
4. Criar uma tarefa com data para hoje/amanha.
5. Criar um evento na agenda para +2 minutos.
6. Criar uma regra de lembrete (minutos antes) com canal **EMAIL** e **WHATSAPP**.
7. Em **Lembretes**, clicar em **Gerar lembretes**.
8. Verificar recebimento por email e WhatsApp.
9. Responder **2** e confirmar novo lembrete em 10 minutos.
10. Responder **1** e confirmar status no historico.
11. Responder **3** e confirmar cancelamento no historico.

Observacao: o webhook deve estar configurado no Meta WhatsApp Cloud com o endpoint:
`/api/notifications/whatsapp/webhook/`.

----- END FILE: docs/TESTE_NOTIFICACOES.md -----

----- BEGIN FILE: docs/dump_completo_projeto_20260213_085131.txt -----
